
\chapter{Statements}
\label{statements}

%--#[ abrackets :

\section{abrackets, antibrackets}
\label{substaabrackets}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & ab[rackets][+][-] {\tt<}list of names{\tt>}; \\
& antib[rackets][+][-] {\tt<}list of names{\tt>}; \\
See also & bracket (\ref{substabracket}) and the chapter on brackets 
     (\ref{brackets})
\end{tabular} \vspace{4mm}

\noindent
This statement\index{abrackets}\index{antibrackets} does the opposite of 
the bracket statement (see \ref{substabracket}). In the bracket statement 
the variables that are mentioned are placed outside brackets and inside the 
brackets are all other objects. In the antibracket statement the variables 
in the list are the only objects that are not placed outside the brackets. 
For the rest of the syntax, see the bracket statement (section 
\ref{substabracket}).
\vspace{10mm}

%--#] abrackets : 
%--#[ also :
 
\section{also}
\label{substaalso}

\noindent \begin{tabular}{ll}
Type & Executable Statement \\
Syntax & a[lso] [options] {\tt<}pattern{\tt>} = 
         {\tt<}expression{\tt>}; \\
See also & identify (\ref{substaidentify}), idold (\ref{substaidold})
\end{tabular} \vspace{4mm}

\noindent The also\index{also} statement should follow either an 
id\index{id} statement or another also statement. The action is that the 
pattern matching in the also statement takes place immediately after the 
pattern matching of the previous id statement (or also statement) and after 
possible matching patterns have been removed, but before the r.h.s. 
expressions are inserted. It is identical to the idold statement (see 
\ref{substaidold}). Example:
\begin{verbatim}
    id    x = cosphi*x-sinphi*y;
    also  y = sinphi*x+cosphi*y;
\end{verbatim}

\noindent The options are explained in the section on the id statement (see 
\ref{substaidentify}). \vspace{10mm}

%--#] also : 
%--#[ antiputinside :

\section{antiputinside}
\label{substaantiputinside}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & antiputinside {\tt<}name of function{\tt>} [,$<$antibracket information$>$];
\\ See also & PutInside (\ref{substaputinside})
\end{tabular}\vspace{4mm}

\noindent This statement\index{antiputinside} puts all parts of the term 
with the exception of the variables in the antibracket information inside a 
function argument. The function must be a regular function (hence no tensor 
or table which are special types of functions). The 
antibracket\index{antibracket} information should adhere to the syntax of 
the bracket statement (\ref{substabracket}, \ref{substaabrackets}) and all 
occurrences of all variables with the exception of the antibracket 
variables will be put inside the function. The coefficient will also be put 
inside the function.
\vspace{10mm}

%--#] antiputinside : 
%--#[ antisymmetrize :

\section{antisymmetrize}
\label{substaantisymmetrize}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & an[tisymmetrize] \verb:{:{\tt<}name of function/tensor{\tt>}
         [{\tt<}argument specifications{\tt>}];\verb:}: \\
See also & symmetrize (\ref{substasymmetrize}), cyclesymmetrize 
(\ref{substacyclesymmetrize}), rcyclesymmetrize (\ref{substarcyclesymmetrize})
\end{tabular} \vspace{4mm}

\noindent The argument specifications are explained in the section on the 
symmetrize statements (see \ref{substasymmetrize}).\medskip

\noindent The action of this statement\index{antisymmetrize} is to 
anti-symmetrize the (specified) arguments of the functions that are 
mentioned. This means that the arguments are brought to `natural order' in 
the notation of \FORM\ and each exchange of arguments or groups of arguments 
results in a minus sign in the coefficient of the term. The `natural order' 
may depend on the order of declaration of the variables. If two arguments 
or groups of arguments that are part in the anti-symmetrization are 
identical, the function is replaced by zero. \vspace{10mm}

%--#] antisymmetrize : 
%--#[ apply :

\section{apply}
\label{substaapply}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & apply ["{\tt<}tablename(s){\tt>}"];
\\ See also & tablebases (\ref{tablebase}), apply (\ref{tblapply})
\end{tabular} \vspace{4mm}

\noindent This statement\index{apply} is explained in the chapter on 
tablebases.\vspace{10mm}

%--#] apply : 
%--#[ argexplode :

\section{argexplode}
\label{substaargexplode}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & argexplode [{\tt<}list of functions{\tt>}] \\
See also & argimplode (\ref{substaargimplode})
\end{tabular} \vspace{4mm}

\noindent See the description of the ArgImplode~\ref{substaargimplode} 
statement.
\vspace{10mm}

%--#] argexplode : 
%--#[ argimplode :

\section{argimplode}
\label{substaargimplode}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & argimplode [{\tt<}list of functions{\tt>}] \\
See also & argexplode (\ref{substaargexplode})
\end{tabular} \vspace{4mm}

\noindent This is a rather specialized statement. It converts one notation 
of indices, used for harmonic sums\index{sums!harmonic}\index{harmonic 
sums}, harmonic 
polylogarithms\index{polylogarithms!harmonic}\index{harmonic 
polylogarithms} and multiple zeta values\index{multiple zeta values} into 
its alternative notation. The two notations are:
\begin{verbatim}
   Z(0,0,0,1,0,0,-1)
   Z(4,-3)
\end{verbatim}
In the first notation the indices can only be 0, 1 and -1. In the second 
notation there can be no zeroes. The `ArgImplode,Z;' 
statement\index{argimplode} would be 
equivalent to the statement
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_ArgImplode_1)
\begin{verbatim}
   repeat id Z(?a,0,x?!{0,0},?b) = Z(?a,x+sig_(x),?b);
\end{verbatim}
and takes one from the first notation to the second. The `ArgExplode,Z;' 
statement\index{argexplode} is equivalent to the statement
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_ArgImplode_1)
\begin{verbatim}
   repeat id Z(?a,x?!{1,0,-1},?b) = Z(?a,0,x-sig_(x),?b);
\end{verbatim}
and takes one from the second notation to the first. The reason that these 
statements have been built in lies in the fact that for many indices the 
repeat statements started to become very time-consuming.

\noindent For the harmonic sums, the harmonic polylogarithms and the 
multiple zeta values one can use the summer6 and the harmpol packages in 
the \FORM\ distribution. They are described in the papers

J.~A.~M. Vermaseren, {\it Harmonic sums, Mellin transforms and integrals},
  {\em Int. J. Mod. Phys.} {\bf A14} (1999) 2037,
  http://arxiv.org/abs/hep-ph/9806280.

E.~Remiddi and J.~A.~M. Vermaseren, {\it Harmonic polylogarithms},  {\em 
Int. J. Mod. Phys.} {\bf A15} (2000) 725,
  http://arxiv.org/abs/hep-ph/9905237.
\vspace{10mm}

%--#] argimplode : 
%--#[ argtoextrasymbol :

\section{argtoextrasymbol}
\label{substaargtoextrasymbol}

\noindent
\begin{tabular}{ll}
Type &
  Executable statement \\
Syntax &
  argtoextrasymbol [tonumber] [{\tt<}argument specifications{\tt>}]; \\
See also &
  topolynomial (\ref{substatopolynomial}) and
  extrasymbols (\ref{substaextrasymbols}, \ref{sect-extrasymbols}).
\end{tabular}
\vspace{4mm}

\noindent
Converts function arguments into extra symbols. 
An argument will be replaced with an extra symbol. 
The arguments that have been encountered before are replaced with the same 
extra symbols. 
Unlike the \texttt{topolynomial} statement (\ref{substatopolynomial}), the 
replacement occurs even for arguments consisting only of numbers and symbols 
(including extra symbols). 
\vspace{4mm}

\noindent
The \texttt{tonumber} option requests that function arguments are converted to 
positive integers corresponding to extra symbols. This provides an efficient 
mapping from any expression (stored as a function argument) to a number. 
\vspace{4mm}

\noindent
The function arguments to be converted can be specified in the same way as the 
\texttt{argument} statement (see \ref{substaargument}). 
\vspace{10mm}

%--#] argtoextrasymbol : 
%--#[ argument :

\section{argument}
\label{substaargument}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & argument [{\tt<}argument specifications{\tt>}] \\ &
    \ \ \ \ \ \ \ \ \ \ \ \
 \verb:{:{\tt<}name of function/set{\tt>}
[{\tt<}argument specifications{\tt>}]\verb:}:; \\
See also & endargument (\ref{substaendargument})
\end{tabular} \vspace{4mm}

\noindent This statement starts an argument\index{argument} 
environment\index{environment!argument}. Such an environment is terminated 
by an endargument statement (see \ref{substaendargument}). The statements 
between the argument and the endargument\index{endargument} statements will 
be applied only to the function arguments as specified by the remaining 
information in the argument statement. This information is given by:
\begin{itemize}
\item   No further information: the statements are applied to all arguments 
of all functions.
\item   A series of numbers: the statements are applied to the given 
arguments of all functions.
\item   A function name (or a set of functions), possibly followed by a 
series of numbers: the statements are applied to the numbered arguments of 
the function specified. If a set of functions was specified, all the 
functions in the set will be taken. If no numbers are specified, all 
arguments of the function (or elements of the set) are taken.
\end{itemize}
The combination of a function (or set) possibly followed by numbers of 
arguments, can occur as many times as needed. The generic numbers of 
arguments that refer to all functions work in addition to the numbers 
specified for individual functions. Example\vspace{1mm}
\begin{verbatim}
   Argument 2,f,1,{f,f1},3,4;
\end{verbatim}
This specifies the second argument of all functions. In addition the first 
argument of \verb:f: will be taken and then also the third and fourth 
arguments of \verb:f: and \verb:f1: will be taken. \vspace{4mm}

\noindent Argument/endargument constructions can be nested. \vspace{10mm}

%--#] argument : 
%--#[ autodeclare :

\section{auto, autodeclare}
\label{substaautodeclare}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & autodeclare {\tt<}variable type{\tt>} {\tt<}list of variables to be declared{\tt>}; \\
       & auto {\tt<}variable type{\tt>} {\tt<}list of variables to be declared{\tt>};
\end{tabular} \vspace{4mm}

\noindent The variable\index{auto}\index{autodeclare} types are 
\vspace{1mm}

\lefttabitem{s[ymbol]}
\tabitem{Declaration of symbols\index{symbols}. For options see \ref{substasymbols}.}

\lefttabitem{v[ector]}
\tabitem{Declaration of vectors\index{vectors}. For options see \ref{substavectors}.}

\lefttabitem{i[ndex]}
\tabitem{Declaration of indices\index{index}. For options see \ref{substaindex}.}

\lefttabitem{i[ndices]}
\tabitem{Declaration of indices\index{indices}. For options see \ref{substaindex}.}

\lefttabitem{f[unctions]}
\tabitem{Declaration of noncommuting\index{noncommuting} 
functions\index{functions!noncommuting}. For options see 
\ref{substanfunctions}.}

\lefttabitem{nf[unctions]}
\tabitem{Declaration of noncommuting functions. For options see 
\ref{substanfunctions}.}

\lefttabitem{cf[unctions]}
\tabitem{Declaration of commuting\index{commuting} 
functions\index{functions!commuting}. For options see 
\ref{substacfunctions}.}

\lefttabitem{co[mmuting]}
\tabitem{Declaration of commuting functions. For options see 
\ref{substacfunctions}.}

\lefttabitem{t[ensors]}
\tabitem{Declaration of commuting tensors\index{tensors!commuting}. For options see 
\ref{substatensors}.}

\lefttabitem{nt[ensors]}
\tabitem{Declaration of noncommuting tensors\index{tensors!noncommuting}. For options see 
\ref{substantensors}.}

\lefttabitem{ct[ensors]}
\tabitem{Declaration of commuting tensors\index{tensors!commuting}. For options see 
\ref{substactensors}.}

\noindent The action of the autodeclare statement is to set a default for 
variable types. In a statement of the type
\begin{verbatim}
   AutoDeclare Symbol a,bc,def;
\end{verbatim}
all undeclared variables of which the name starts with the character a, the 
string bc or the string def will be interpreted as symbols and entered in 
the name tables as such. In the case there are two statements as in
\begin{verbatim}
   AutoDeclare CFunction b,d;
   AutoDeclare Symbol a,bc,def;
\end{verbatim}
all previously undeclared variables of which the name starts with a, bc or 
def will be declared as symbols. All other previously undeclared variables 
of which the name starts with a b or a d will be declared as commuting 
functions. This is independent of the order of the autodeclare statements. 
{\FORM} starts looking for the most detailed matches 
first. Hence the variable defi will match with the string def first.
\vspace{4mm}

\noindent It is also allowed to use the properties of the various variables 
in the autodeclare statement:
\begin{verbatim}
   AutoDeclare Index i=4,i3=3,i5=5;
\end{verbatim}
This declares all previously undeclared variables of which the name starts 
with an i to be four dimensional indices, unless their names start with i3 in 
which case they will be three dimensional indices, or their names start 
with i5 in which case they will be five dimensional indices. \vspace{10mm}

%--#] autodeclare : 
%--#[ bracket :

\section{bracket}
\label{substabracket}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & b[rackets][+][-] {\tt<}list of names{\tt>}; \\
See also & antibracket (\ref{substaabrackets}), keep (\ref{substakeep}),
    collect(\ref{substacollect}) and the chapter on brackets 
     (\ref{brackets})
\end{tabular} \vspace{4mm}

\noindent This statement causes the output to be reorganized in such a way 
that all objects in the `list of names' are placed outside 
brackets\index{bracket} and all remaining objects inside 
brackets\index{brackets}. This grouping will remain till the next time that 
the expression is active and is being manipulated. Hence the brackets can 
survive skip (see \ref{substaskip}), hide (see \ref{substahide}) and even 
save (see \ref{substasave}) and load (see \ref{substaload}) statements. The 
bracket information can be used by the collect (see \ref{substacollect}) 
and keep (see \ref{substakeep}) statements, as well in r.h.s.\ expressions 
when the contents of individual brackets of an expression can be picked up 
(see \ref{brackets}). \vspace{4mm}

\noindent The list of names can contain names of symbols, vectors, 
functions, tensors and sets. In addition it can contain dotproducts. There 
should be only one bracket or antibracket (see \ref{substaabrackets}) 
statement in each module. If there is more than one, only the last one has 
an effect. The presence of a set has the same effect as having all the 
symbolic elements of the set declared in the (anti)bracket 
statement.\vspace{4mm}

\noindent The presence of a $+$ or $-$ after the bracket (or anti bracket) 
refers to potential indexing of the brackets\index{brackets!indexing}. 
Usually {\FORM} has the information inside the terms in an expression. If 
it needs to search for a particular bracket it does so by starting at the 
beginning of that expression. This can be slow. If one likes to access 
individual brackets, it may be faster to tell {\FORM} to make an index by 
putting the $+$ after the bracket or antibracket keyword. For more 
information, see the chapter on brackets (see \ref{brackets}). A $-$ 
indicates that no index should be made. Currently this is the default and 
hence there is no need to use this option. It is present just in case the 
default might be changed in a future version of {\FORM} (in which {\FORM} 
might for instance try to determine by itself what seems best. This option 
exists for case that the user would like to overrule such a mechanism). 
\vspace{4mm}

\noindent See also the antibracket statement in \ref{substaabrackets}.
\vspace{10mm}

%--#] bracket : 
%--#[ break :
%
\section{break}
\label{substabreak}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & break; \\
\\ See also & case (\ref{substacase}), switch (\ref{substaswitch}),
		 default(\ref{substadefault}), endswitch (\ref{substaendswitch}).
\end{tabular} \vspace{4mm}

\noindent When a break statement is reached in a switch construction the 
next statement to be executed is the first statement after the 
corresponding endswitch statement.

\vspace{10mm}
%
%--#] break : 
%--#[ case :
%
\section{case}
\label{substacase}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & case,number; \\
\\ See also & switch (\ref{substaswitch}), break (\ref{substabreak}),
		 default(\ref{substadefault}), endswitch (\ref{substaendswitch}).
\end{tabular} \vspace{4mm}

\noindent The cases in a switch construction are marked by a number. This 
number must be an integer that can be represented inside a {\FORM} word. 
On a 64-bit processor this would be an integer in the range $-2^{31}$ to 
$2^{31}-1$. If the dollar variable in the switch statement has the same 
value as the integer in the case statement, the next statement to be 
executed is the first statement after the case statement. Usually cases are 
terminated by break statements, but if there is no break statement 'fall 
through' may occur in which execution continues with the first statement 
after the next case statement or default statement.

\vspace{10mm}
%
%--#] case : 
%--#[ cfunctions :

\section{cfunctions}
\label{substacfunctions}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & c[functions] {\tt<}list of functions to be declared{\tt>}; \\
See also & functions (\ref{substafunctions}), nfunctions (\ref{substanfunctions})
\end{tabular} \vspace{4mm}

\noindent This statement declares commuting\index{commuting} 
functions\index{functions!commuting}. The name of a 
function can be followed by some information that specifies additional 
properties of the preceding function. These can be (name indicates the 
name of the function to be declared): \vspace{4mm}

\leftvitem{4.1cm}{name{\hash}r}
\rightvitem{12cm}{The function is considered to be a real\index{real} function (default).}

\leftvitem{4.1cm}{name{\hash}c}
\rightvitem{12cm}{The function is considered to be a complex\index{complex} function. This means 
that internally two spaces are reserved. One for the variable name and one 
for its complex conjugate name{\hash}.}

\leftvitem{4.1cm}{name{\hash}i}
\rightvitem{12cm}{The function is considered to be imaginary\index{imaginary}.}

\leftvitem{4.1cm}{name(s[ymmetric])}
\rightvitem{12cm}{The function is totally symmetric\index{symmetric}. This means that during 
normalization {\FORM} will order the arguments according to its internal 
notion of order by trying permutations. The result will depend on the order 
of declaration of variables.}

\leftvitem{4.1cm}{name(a[ntisymmetric])}
\rightvitem{12cm}{The function is totally antisymmetric\index{antisymmetric}. This means that 
during normalization {\FORM} will order the arguments according to its 
internal notion of order and if the resulting permutation of arguments is 
odd the coefficient of the term will change sign. The order will depend on 
the order of declaration of variables.}

\leftvitem{4.1cm}{name(c[yclesymmetric])}
\rightvitem{12cm}{The function is cycle\index{cycle symmetric} symmetric in 
all its arguments. This means that during normalization {\FORM} will order 
the arguments according to its internal notion of order by trying cyclic 
permutations. The result will depend on the order of declaration of 
variables.}

\leftvitem{4.1cm}{name(r[cyclesymmetric)

name(r[cyclic])

name(r[eversecyclic])}
\rightvitem{12cm}{The function is reverse\index{reverse cycle symmetric} 
cycle symmetric in all its arguments. This means that during normalization 
{\FORM} will order the arguments according to its internal notion of order 
by trying cyclic permutations and/or a complete reverse order of all 
arguments. The result will depend on the order of declaration of 
variables.}

\noindent The complexity properties and the symmetric properties can be 
combined. In that case the complexity properties should come first as in
\begin{verbatim}
    CFunction f1#i(antisymmetric);
\end{verbatim}
\vspace{10mm}

%--#] cfunctions : 
%--#[ chainin :
 
\section{chainin}
\label{substachainin}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & Chainin,name of function;
\\ See also & chainout (\ref{substachainout})
\end{tabular} \vspace{4mm}

\noindent Has\index{chainin} the same effect as the statement
\begin{verbatim}
   repeat id f(?a)*f(?b) = f(?a,?b);
\end{verbatim}
if f is the name of the function specified. The chainin statement is just a 
faster shortcut. \vspace{10mm}

%--#] chainin : 
%--#[ chainout :
 
\section{chainout}
\label{substachainout}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & Chainout,name of function;
\\ See also & chainin (\ref{substachainin})
\end{tabular} \vspace{4mm}

\noindent Has\index{chainout} the same effect as the statement
\begin{verbatim}
   repeat id f(x1?,x2?,?a) = f(x1)*f(x2,?a);
\end{verbatim}
if f is the name of the function specified. The chainout statement is just a 
much faster shortcut. \vspace{10mm}

%--#] chainout : 
%--#[ chisholm :

\section{chisholm}
\label{substachisholm}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & chisholm [options] {\tt<}spinline indices{\tt>}; \\
See also & trace4 (\ref{substatrace}) and the chapter on gamma algebra 
(\ref{gammaalgebra})
\end{tabular} \vspace{4mm}

\noindent This statement\index{chisholm} applies the identity
\begin{eqnarray}
    \gamma_a\gamma_\mu\gamma_b \Tr[\gamma_\mu S] & = &
         2\gamma_a( S + S^R ) \gamma_b  \nonumber
\end{eqnarray}
\setcounter{equation}{2}
in order to contract traces. $S$ is here a string of
gamma\index{gamma matrices} matrices and $S^R$ is the reverse string. This 
identity is particularly useful when the matrices $\gamma_6 = 1+\gamma_5$ 
and/or $\gamma_7 = 1-\gamma_5$ are involved. The spinline\index{spinline} index refers to 
which trace should be eliminated this way. The options are \vspace{1mm}
 
\lefttabitem{symmetrize}
\tabitem{If there is more than one contraction with other gamma matrices, 
the answer will be the sum of the various contractions, divided by the 
number of different contractions. This will often result in a minimization 
of the number of $\gamma_5$ matrices left in the final results.}

\lefttabitem{nosymmetrize}
\tabitem{The first contraction encountered will be taken. No attempt is 
made to optimize with respect to the number of $\gamma_5$ matrices left.}

\noindent IMPORTANT: the above identity is only valid in 4 dimensions. For 
more details, see chapter \ref{gammaalgebra} on gamma\index{gamma algebra} algebra. \vspace{10mm}

%--#] chisholm : 
%--#[ cleartable :

\section{cleartable}
\label{substacleartable}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & ClearTable [{\tt<}list of tables{\tt>}]
\end{tabular} \vspace{4mm}

\noindent This statement clears the tables that are mentioned. Sometimes 
(sparse) tables can take so much space that there is no room for new 
elements, while old elements are not needed any longer. In that case one 
can clear the table and start all over again with filling it. It is also 
useful when one wants to reuse a table, but now with a different content.
\vspace{10mm}

%--#] cleartable : 
%--#[ collect :

\section{collect}
\label{substacollect}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & collect {\tt<}name of function{\tt>}; \\
       & collect {\tt<}name of function{\tt>} 
        {\tt<}name of other function{\tt>}; \\
       & collect {\tt<}name of function{\tt>} 
        {\tt<}name of other function{\tt>} {\tt<}percentage{\tt>};
\\ See also & bracket (\ref{substabracket}), antibracket 
     (\ref{substaabrackets}) and the chapter on brackets 
     (\ref{brackets})
\end{tabular} \vspace{4mm}

\noindent Upon processing\index{collect} the expressions (hence expressions 
in hide as well as skipped expressions do not take part in this) the 
contents of the brackets\index{brackets} (if there was a bracket or 
antibracket\index{antibracket} statement in the preceding module) are 
collected and put inside the argument of the named function. Hence if the 
expression \verb:F: is given by
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Collect_1)
% TODO: the term order has been changed.
\begin{verbatim}
   F =
      a*(b^2+c)
    + a^2*(b+6)
    + b^3 + c*b + 12;
\end{verbatim}
the statement
\begin{verbatim}
   Collect cfun;
\end{verbatim}
will change \verb:F: into
\begin{verbatim}
   F = a*cfun(b^2+c)+a^2*cfun(b+6)+cfun(b^3+c*b+12);
\end{verbatim}
The major complication\index{complication} occurs if the content of a 
bracket is so long that it will not fit inside a single term. The maximum 
size of a term is limited by the setup parameter 
maxtermsize\index{maxtermsize} (see \ref{setupmaxtermsize}). If this size 
is exceeded, {\FORM} will split the bracket contents over more than one term, 
in each of which it will be inside the named function. It will issue a 
warning that it has done so. \vspace{4mm}

\noindent If a second function is specified (the 
alternative\index{alternative} collect function) and if a bracket takes 
more space than can be put inside a single term, the bracket contents will 
be split over more than one term, in each of which it will be inside the 
alternative collect function. In this case there is no need for a 
warning\index{warning} 
as the user can easily check whether this has occurred by checking whether 
the alternative function is present in the expression. \vspace{4mm}

\noindent If additionally a percentage\index{percentage} is specified (an 
integer in the range of 1 to 99) this determines how big the argument must 
be as compared to MaxTermSize (see chapter \ref{setup} on the setup) before 
use is made of the alternate collect function. \vspace{10mm}

%--#] collect : 
%--#[ commuteinset :
 
\section{commuteinset}
\label{substacommuteinset}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & commuteinset {\tt<}$\{$list of noncommuting functions/tensors$\}${\tt>}; \\
See also & functions (\ref{substafunctions})
\end{tabular} \vspace{4mm}

\noindent This statement\index{commuteinset} allows one or more sets of 
noncommuting functions and or tensors for its argument(s). The functions 
inside each set will commute with each other. It is allowed to have the 
same function inside more than one set. For a function to commute with 
itself (with for instance different arguments) it needs to be specified 
twice inside the same set. In that case it is more efficient to have a 
separate set with only two arguments. Example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_CommuteInSet_1)
\begin{verbatim}
    I   i1,...,i10;
    F   A1,...,A10;
    CommuteInSet{A1,A3,A5},{A1,g_},{A1,A1};
    L   F = A5*A1*A5*A1*A5*A2*A3*A5*A1*A5*A3*A1;
    L   G = g_(2,i1)*g_(2,i2,i3)*A1(i2)*g_(1,i4)*g_(1,5_,i5,i6)
                    *A1(i1)*A1(i3)*g5_(1)*A3(i5)*A3(i4)*g5_(1);
    Print +f +s;
    .end

   F =
       + A1*A1*A5*A5*A5*A2*A1*A1*A3*A3*A5*A5;
   G =
       + g_(1,i4,i5,i6)*g_(2,i1,i2,i3)*A1(i1)*A1(i2)*A1(i3)*
       A3(i5)*A3(i4)*g_(1,5_);
\end{verbatim}
\vspace{10mm}

%--#] commuteinset : 
%--#[ commuting :
 
\section{commuting}
\label{substacommuting}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & co[mmuting] {\tt<}list of functions to be declared{\tt>}; \\
See also & cfunctions (\ref{substacfunctions}), functions (\ref{substafunctions})
\end{tabular} \vspace{4mm}

\noindent This statement\index{commuting} is completely identical to the 
cfunction statement (see \ref{substacfunctions}). \vspace{10mm}

%--#] commuting : 
%--#[ compress :

\section{compress}
\label{substacompress}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & comp[ress] {\tt<}on/off{\tt>};
\\ See also & on (\ref{substaon}), off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent This statement\index{compress} is obsolete. The user should try 
to use the compress option of the on (see \ref{substaon}) or the off (see 
\ref{substaoff}) statements. \vspace{10mm}

%--#] compress : 
%--#[ contract :

\section{contract}
\label{substacontract}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & contract [{\tt<}argument specifications{\tt>}];
\end{tabular} \vspace{4mm}

\noindent Statement\index{contract} causes the contraction of pairs of 
Levi-Civita\index{Levi-Civita} tensors\index{tensor!Levi-Civita} \verb:e_: 
(see also \ref{functions}) into combinations of Kronecker\index{Kronecker} 
delta's\index{delta!Kronecker}. If there are contracted indices, and if 
their dimension is identical to the number of indices of the Levi-Civita 
tensors, the regular shortcuts are taken. If there are contracted indices 
with a different dimension, the contraction treats these indices 
temporarily as different and lets the contraction be ruled by the 
contraction mechanism of the Kronecker delta's. In practise this means that 
the dimension will enter via $\delta^{\mu}_{\mu} \rightarrow {\rm 
dim}(\mu)$. \vspace{4mm}

\noindent In {\FORM} there are no upper\index{upper} and lower\index{lower} 
indices\index{indices!lower}\index{indices!upper}. Of course the user can 
emulate those. The contract statement always assumes that there is a proper 
distribution of upper and lower indices if the user decided to work in a 
metric in which this makes a difference. Note however that due to the fact 
that the Levi-Civita tensor is considered to be imaginary, there is usually 
no need to do anything special. This is explained in the chapter on 
functions (see \ref{functions}). \vspace{4mm}

\noindent There are several options to control which contractions will be 
taken. They are \vspace{1mm}

\lefttabitem{Contract;}
\tabitem{Here only a single pair of Levi-Civita tensors will be contracted. 
The pair that is selected by {\FORM} is the pair that will give the smallest 
number of terms in their contraction.}

\leftvitem{4cm}{Contract {\tt <}number{\tt>};}
\rightvitem{12cm}{This tells {\FORM} to keep contracting pairs of Levi-Civita tensors 
until there are {\tt <}number{\tt>} or {\tt <}number{\tt>}$+1$ 
Levi-Civita tensors left. A common example is

Contract 0;

which will contract as many pairs as possible.}

\leftvitem{4cm}{Contract:{\tt<}number{\tt>};}
\rightvitem{12cm}{Here the number indicates the number of indices in the 
Levi-Civita tensors to be contracted. Only a single pair will be 
contracted and it will be the pair that gives the smallest number of 
terms.}

\leftvitem{4cm}{Contract:{\tt<}number{\tt>}

\hfill {\tt<}number{\tt>};}
\rightvitem{12cm}{The First number refers to the number of indices in the 
Levi-Civita tensors to be contracted. The second number refers to the 
number of Levi-Civita tensors that should be left (if possible) after 
contraction.}

\noindent Note that the order in which {\FORM} selects the contractions is by 
looking at which pair will give the smallest number of terms. This means 
that usually the largest buildup of terms is at the end. This is not always 
the case, because there can be a complicated network of contracted indices. 
\vspace{10mm}

%--#] contract : 
%--#[ copyspectator :

\section{copyspectator}
\label{substacopyspectator}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & copyspectator {\tt<}exprname = spectator;{\tt>};
\end{tabular} \vspace{4mm}

\noindent See chapter\ref{spectators} on spectators.
\vspace{10mm}

%--#] copyspectator : 
%--#[ createspectator :

\section{createspectator}
\label{substacreatespectator}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & createspectator {\tt<}spectatorname, "filename";{\tt>};
\end{tabular} \vspace{4mm}

\noindent See chapter\ref{spectators} on spectators.
\vspace{10mm}

%--#] createspectator : 
%--#[ ctable :

\section{ctable}
\label{substactable}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & ctable {\tt<}options{\tt>} {\tt<}table to be 
declared{\tt>}; \\
See also & functions (\ref{substafunctions}), table (\ref{substatable}),
        ntable (\ref{substantable})
\end{tabular} \vspace{4mm}

\noindent This statement declares a commuting\index{commuting} 
table\index{table!commuting} and is identical to the table command (see 
\ref{substatable}) which has the commuting property as its default. 
\vspace{10mm}

%--#] ctable : 
%--#[ ctensors :
 
\section{ctensors}
\label{substactensors}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & ct[ensors] {\tt<}list of tensors to be declared{\tt>}; \\
See also & functions (\ref{substafunctions}), tensors 
        (\ref{substatensors}), ntensors (\ref{substantensors})
\end{tabular} \vspace{4mm}

\noindent This statement declares commuting\index{commuting} 
tensors\index{tensor!commuting}. It is equal to the tensor statement (see 
\ref{substatensors}) which has the commuting property as its default. 
\vspace{10mm}

%--#] ctensors : 
%--#[ cyclesymmetrize :

\section{cyclesymmetrize}
\label{substacyclesymmetrize}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & cy[clesymmetrize] \verb:{:{\tt<}name of function/tensor{\tt>}
         [{\tt<}argument specifications{\tt>}];\verb:}: \\
See also & symmetrize (\ref{substasymmetrize}), antisymmetrize 
(\ref{substaantisymmetrize}), rcyclesymmetrize (\ref{substarcyclesymmetrize})
\end{tabular} \vspace{4mm}

\noindent The argument\index{cyclesymmetrize} specifications are explained 
in the section on the symmetrize statements (see \ref{substasymmetrize}). 
\medskip

\noindent The action of this statement is to cycle-symmetrize the (specified) 
arguments of the functions that are mentioned. This means that the 
arguments are brought to `natural order' in the notation of \FORM\ by trying 
cyclic permutations of the arguments or groups of arguments. The `natural 
order' may depend on the order of declaration of the variables. 
\vspace{10mm}

%--#] cyclesymmetrize : 
%--#[ deallocatetable :
 
\section{deallocatetable}
\label{substadeallocatetable}

\noindent \begin{tabular}{ll}
Type & Declaration\\
Syntax & DeallocateTable,name(s) of sparse table(s);
\\ See also & table (\ref{substatable}), fill (\ref{substafill}),
   table bases (\ref{tablebase})
\end{tabular} \vspace{4mm}

\noindent Works\index{deallocatetable} only for sparse\index{sparse} 
tables\index{table!sparse}. Deallocates all definitions of elements as 
obtained with `Fill'\index{fill} statements as if there never were any 
`Fill' statements for the given tables.

This statement exists because sometimes cleaning up big tables is needed 
when they take too much memory. This can be the case when a big tablebase 
has been used. \vspace{10mm}

%--#] deallocatetable : 
%--#[ default :
%
\section{default}
\label{substadefault}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & default; \\
\\ See also & case (\ref{substacase}), break (\ref{substabreak}),
		 switch(\ref{substaswitch}), endswitch (\ref{substaendswitch}).
\end{tabular} \vspace{4mm}

\noindent This is the default case in a switch construction.

\vspace{10mm}
%
%--#] default : 
%--#[ delete :

\section{delete}
\label{substadelete}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & delete storage; \\
See also & save (\ref{substasave}), load (\ref{substaload}) \\
Syntax & delete extrasymbols; \\
Syntax & delete extrasymbols\textgreater{}number; \\
See also & extrasymbols (\ref{substaextrasymbols}) \\

\end{tabular} \vspace{4mm}

\noindent This statement has currently two varieties. The delete 
storage\index{delete} clears the complete storage\index{storage file} 
file\index{file!storage} and reduces it to zero size. The effect is that 
all stored expressions are removed from the system. Because it is 
impossible to remove individual expressions from the store file (there is 
no mechanism to fill the resulting holes) it is the only way to clean up 
the storage file. If some expressions should be excluded from this 
elimination process, one should copy them first into active global 
expressions, then delete the storage file, after which the expressions can 
be written to storage again with a .store\index{.store} instruction.

\noindent The delete extrasymbols\index{delete}\index{} variety removes 
extra symbols\index{extra symbols} from the list. The default is that all 
extra symbols are removed, but one can also remove the symbols above a 
given number as in
\begin{verbatim}
   #$es = `extrasymbols_';
   ToPolynomial;
     ....some code....
   .sort
   * now the new extra symbols are not needed anylonger
   Delete extrasymbols>`$es';
\end{verbatim}
\vspace{10mm}

%--#] delete : 
%--#[ denominators :

\section{denominators}
\label{substadenominators}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & denominators functionname;
\end{tabular} \vspace{4mm}

\noindent This statement\index{denominators} allows the user to rename all 
occurrences of the built-in denominator function. This built-in function is 
kind of an oddity inside \FORM\@. Denominators are presented by a very special 
function which doesn't really have a name and hence is rather hard to 
address. In addition there are special rules connected to denominators. 
Hence it is usually better to collect denominators inside functions that 
have been defined by the user and hence allow the user to manipulate them 
at will. Yet, objects can end up inside denominator functions, especially 
when output from other programs is read in. Hence this statement allows all 
occurrences of the denominator function to be renamed into the function 
that is given in the statement. This function will work well together with 
the PolyRatFun statement in which we define a PolyFun with two arguments of 
which the second acts as a denominator and the first as a numerator:
\begin{verbatim}
   PolyRatFun,rat;
   Denominators,den;
   id den(x?) = rat(1,x);
\end{verbatim}
For more about this one should consult the part on the 
PolyRatFun\index{polyratfun} statement 
(\ref{substapolyratfun}) and the chapter on polynomials (still to be 
included because the current version can handle only polynomials in a 
single variable and is also not optimized for many occurrences that have 
identical denominators).
\vspace{10mm}

%--#] denominators : 
%--#[ dimension :
 
\section{dimension}
\label{substadimension}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & d[imension] {\tt<}number or symbol{\tt>};
\\ See also & index (\ref{substaindex})
\end{tabular} \vspace{4mm}

\noindent Sets the default dimension\index{dimension!default}. This default 
dimension determines the dimension of the indices\index{indices} that are 
being declared without dimension specification as well as the dimension of 
all dummy indices\index{indices!dummy}. At the moment an index is declared 
and there is no dimension specification, {\FORM} looks for the default 
dimension and uses that. This index will then have this dimension, even 
when the default dimension is changed at a later moment. The dummy indices 
always have the dimension of the current default dimension. If the default 
dimension is changed the dimension of all dummy indices changes with it. 
Varieties: \vspace{1mm}

\leftvitem{4cm}{Dimension {\tt<}number{\tt>};}
\rightvitem{12cm}{Declares the number to be the default dimension. The number must be smaller than
32768 on 32bit architectures or 2147483648 on 64bit architectures. Negative numbers are not allowed.
If one wants to work with negative dimensions, the practical workaround is to use a symbolic
dimension and later replace that symbol appropriately.}

\leftvitem{4cm}{Dimension {\tt<}symbol{\tt>};}
\rightvitem{12cm}{Symbol must be the name of a symbol, either previously 
declared or declarable because of an auto-declaration (see 
\ref{substaautodeclare}). Declares the symbol to be the default dimension.}

\leftvitem{4cm}{Dimension

\hfill {\tt<}symbol{\tt>}:{\tt<}symbol{\tt>};}
\rightvitem{12cm}{The symbols\index{symbols} must be the names of symbols, 
either previously declared or declarable because of an auto-declaration 
(see \ref{substaautodeclare}). The first symbol will be the default 
dimension. The second symbol will be the first symbol minus 4. It will 
be used as such in the trace\index{trace contractions} 
contractions\index{contractions!trace}. See also \ref{substatracen} and 
\ref{substaindex}.}

\noindent Examples:
\begin{verbatim}
   Dimension 3;
   Dimension n;
   Dimension n:[n-4];
\end{verbatim}
The default dimension in {\FORM} is 4. \vspace{10mm}

%--#] dimension : 
%--#[ discard :

\section{discard}
\label{substadiscard}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & dis[card];
\end{tabular} \vspace{4mm}

\noindent This statement discards\index{discard} the current term. It can 
be very useful in statements of the type
\begin{verbatim}
   if ( count(x,1) > 5 ) Discard;
\end{verbatim}
which eliminates all terms that have more than five powers of x. 
\vspace{10mm}

%--#] discard : 
%--#[ disorder :

\section{disorder}
\label{substadisorder}

\noindent \begin{tabular}{ll}
Type & Executable statement \\
Syntax & disorder {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement is identical to the disorder\index{disorder} 
option\index{option!disorder} of the id\index{id statement}\index{id} 
statement (see \ref{substaidentify}). It is just a shorthand notation for 
`id disorder'. \vspace{10mm}

%--#] disorder : 
%--#[ do :

\section{do}
\label{substado}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & do \$loopvar = lowvalue,highvalue\verb:{:,increment\verb:}:;
\\ See also & enddo (\ref{substaenddo})
\end{tabular} \vspace{4mm}

\noindent The syntax is the typical syntax for do-loops. The loop variable 
has to be a dollar variable. For parallel performance this variable can be 
declared local in a moduleoption (see \ref{substamoduleoption}) statement, 
unless it is also used in other ways in the current module. The loop 
parameters should either be (short) integers or dollar variables or factors 
of dollar variables provided they evaluate at run time to (short) integers. 
The enddo statement should be in the same module as the do statement. In 
addition it should be properly nested with if, repeat, while and argument 
constructions.

\noindent The do-loop facility is in principle superfluous, because the 
repeat~(\ref{substarepeat}), if~(\ref{substaif}) and the pattern matcher can 
basically do everything the do-loop can do. Sometimes however the do-loop 
is easier to program and gives more readable code as shown here:
\begin{verbatim}
   do $i = 1,5;
      id,only,x^$i = f(F[factor_^$i]);
   enddo;
\end{verbatim}
\noindent versus
\begin{verbatim}
   id,only,x^n?{1,2,3,4,5} = ff(n);
   repeat id ff(n?pos_) = ff(n-1)*f(F[factor_^n]);
   id ff(n?neg0_) = 1;
\end{verbatim}
\noindent One should note that the do-loop is evaluated at run time. Hence 
the dollar variables need to be evaluated at run time as well. Therefore, 
if it is possible, the preprocessor variety (see \ref{predo}) is almost 
always faster in execution as in
\begin{verbatim}
   #do i = 1,5
      id,only,x^`i' = f(F[factor_^`i']);
   #enddo
\end{verbatim}
\noindent This can of course not be done in constructions like
\begin{verbatim}
   id  f1(x?$x) = f2(x);
   FactDollar,$x;
   Do $i = 1,$x[0];
     Multiply f($i,$x[$i]);
   Enddo;
\end{verbatim}
\noindent because here \verb:$x: and its factors are only known at run time 
and may be different for each term.
\vspace{10mm}

%--#] do : 
%--#[ drop :

\section{drop}
\label{substadrop}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & drop; \\
       & drop {\tt<}list of expressions{\tt>};
\\ See also & ndrop (\ref{substandrop})
\end{tabular} \vspace{4mm}

\noindent In the first variety this statement\index{drop} eliminates all 
expressions\index{expression} from the system. In the second variety it 
eliminates only the expressions that are mentioned from the system. All 
expressions that are to be dropped can still be used in the r.h.s.\ of other 
expressions inside the current module. Basically the expressions to be 
dropped are not treated for execution and after the module has finished 
completely they are removed. See also the ndrop 
statement~\ref{substandrop}. \vspace{10mm}

%--#] drop : 
%--#[ dropcoefficient :

\section{dropcoefficient}
\label{substadropcoefficient}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & DropCoefficient;
\end{tabular} \vspace{4mm}

\noindent This statement replaces the coefficient of the current term by 
one. In principle it has the same effect as
\begin{verbatim}
   Multiply 1/coeff_;
\end{verbatim}
but there is always the philosophical issue what is the coefficient once 
one enters function arguments. Inside an 
Argument/EndArgument\index{argument}\index{endargument} environment this 
statement would drop the coefficient of the terms inside the argument.
\vspace{10mm}

%--#] dropcoefficient : 
%--#[ dropsymbols :

\section{dropsymbols}
\label{substadropsymbols}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & DropSymbols;
\end{tabular} \vspace{4mm}

\noindent This statement removes all symbols from a term. 
It has the same effect as
\begin{verbatim}
   id,many,x?^n? = 1;
\end{verbatim}
(x and n are symbols) except for that it is much faster.
\vspace{10mm}

%--#] dropsymbols : 
%--#[ else :

\section{else}
\label{substaelse}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & else;
\\ See also & if (\ref{substaif}),
              elseif (\ref{substaelseif}),
              endif (\ref{substaendif})
\end{tabular} \vspace{4mm}

\noindent To be used in combination with an if statement (see 
\ref{substaif}). The statements following the
else\index{else statement}\index{else} statement until the matching 
endif\index{endif statement}\index{endif} 
statement (see \ref{substaendif}) will be executed for the current term if 
the conditions of the matching proceeding if\index{if statement}\index{if} 
statement and/or all corresponding elseif\index{elseif} statements (see 
\ref{substaelseif}) are false. If any of the conditions of the matching 
proceeding if or elseif statements are true the statements following the 
else statement will be skipped. \vspace{10mm}

%--#] else : 
%--#[ elseif :
 
\section{elseif}
\label{substaelseif}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & elseif ( {\tt<}condition{\tt>} );
\\ See also & if (\ref{substaif}),
              else (\ref{substaelse}),
              endif (\ref{substaendif})
\end{tabular} \vspace{4mm}

\noindent Should be proceeded by an if\index{if statement}\index{if} 
statement (see \ref{substaif}) and followed at least by a matching 
endif\index{endif statement}\index{endif} 
statement (see \ref{substaendif}). If the conditions of the proceeding 
matching if statement and all proceeding matching
elseif\index{elseif statement}\index{elseif} statements are false the 
condition of this elseif statement will be evaluated. If it is true, the 
statements following it until the next matching elseif,
else\index{else statement}\index{else} or endif statement will be executed. 
If not, control is passed to this next elseif, else or endif statement. The 
syntax for the condition is exactly the same as for the condition in the if 
statement. \vspace{10mm}
 
%--#] elseif : 
%--#[ emptyspectator :

\section{emptyspectator}
\label{substaemptyspectator}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & emptyspectator {\tt<}spectator;{\tt>};
\end{tabular} \vspace{4mm}

\noindent See chapter\ref{spectators} on spectators.
\vspace{10mm}

%--#] emptyspectator : 
%--#[ endargument :

\section{endargument}
\label{substaendargument}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endargument; \\
See also & argument (\ref{substaargument})
\end{tabular} \vspace{4mm}

\noindent Terminates an argument environment\index{environment!argument} 
(see \ref{substaargument}). The argument\index{argument} statement and its 
corresponding endargument\index{endargument} statement must belong to the 
same module. Argument environments can be nested with all other 
environments. \vspace{10mm}

%--#] endargument : 
%--#[ enddo :

\section{enddo}
\label{substaenddo}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & enddo;
\\ See also & do (\ref{substado})
\end{tabular} \vspace{4mm}

See the do statement (\ref{substado}).
\vspace{10mm}

%--#] enddo : 
%--#[ endif :

\section{endif}
\label{substaendif}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endif;
\\ See also & if (\ref{substaif}),
              elseif (\ref{substaelseif}),
              else (\ref{substaelse})
\end{tabular} \vspace{4mm}

\noindent Terminates an if\index{if statement}\index{if} construction (see \ref{substaif}, 
\ref{substaelseif} and \ref{substaelse}). If should be noted that 
if\index{endif statement}\index{endif} 
constructions can be nested.
\vspace{10mm}

%--#] endif : 
%--#[ endinexpression :
 
\section{endinexpression}
\label{substaendinexpression}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endinexpression;
\\ See also & inexpression(\ref{substainexpression})
\end{tabular} \vspace{4mm}

\noindent Only to be used in combination with the 
inexpression\index{endinexpression}\index{inexpression} statement. The 
combination
\begin{verbatim}
   InExpression,expr;
       Statements;
   EndInExpression;
\end{verbatim}
is a more readable version of the construction
\begin{verbatim}
   if ( expression(expr) );
       Statements;
   endif;
\end{verbatim}
\vspace{10mm}

%--#] endinexpression : 
%--#[ endinside :

\section{endinside}
\label{substaendinside}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endinside;
\\ See also & inside (\ref{substainside}) and the chapter on \$-variables 
(\ref{dollars})
\end{tabular}\vspace{4mm}

\noindent Terminates an `inside'\index{inside} 
environment\index{environment!inside} (see \ref{substainside}) which is 
used to operate on the contents of \$-variables\index{\$-variable} (see 
\ref{dollars}).\vspace{10mm}

%--#] endinside : 
%--#[ endrepeat :

\section{endrepeat}
\label{substaendrepeat}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endrepeat;
\\ See also & repeat (\ref{substarepeat}), while (\ref{substawhile})
\end{tabular} \vspace{4mm}

\noindent Ends the repeat\index{repeat} 
environment\index{environment!repeat}. The repeat environment is started 
with a repeat statement (see \ref{substarepeat}). The repeat and its 
matching endrepeat\index{endrepeat} should be inside the same module. 
Repeat environments can be nested with all other environments (and other 
repeat environments). \vspace{10mm}

%--#] endrepeat : 
%--#[ endswitch :
%
\section{endswitch}
\label{substaendswitch}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endswitch; \\
\\ See also & case (\ref{substacase}), break (\ref{substabreak}),
		 default(\ref{substadefault}), switch (\ref{substaswitch}).
\end{tabular} \vspace{4mm}

\noindent Ends a switch construction. It collects the various cases, puts 
them in order and decides whether the lookup of cases should be done by 
means of a jumptable, or by binary searching. The ratio (spread in 
cases)/(number of cases) determines whether a jumptable is constructed. The 
default value below which a jumptable is constructed is 4. This value can 
be changed in the setups (see the section on the setups \ref{setup}) with 
the variable jumpratio.

\vspace{10mm}
%
%--#] endswitch : 
%--#[ endterm :

\section{endterm}
\label{substaendterm}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endterm;
\\ See also & term (\ref{substaterm}), sort (\ref{substasort})
\end{tabular} \vspace{4mm}

\noindent Terminates a term\index{term} environment\index{environment!term} 
(see \ref{substaterm}). Term environments\index{endterm} can be nested with 
other term environments and with other environments in general. The whole 
environment should be part of one single module. See also \ref{substasort}. 
\vspace{10mm}

%--#] endterm : 
%--#[ endwhile :

\section{endwhile}
\label{substaendwhile}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & endwhile;
\\ See also & while (\ref{substawhile}), repeat (\ref{substarepeat})
\end{tabular} \vspace{4mm}

\noindent Terminates a while\index{while} environment\index{environment!while} (see \ref{substawhile}). The while 
statement and its corresponding endwhile\index{endwhile} statement must be part of the same 
module. \vspace{10mm}

%--#] endwhile : 
%--#[ exit :

\section{exit}
\label{substaexit}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & exit ["{\tt<}string{\tt>}"];
\\ See also & setexitflag (\ref{substasetexitflag})
\end{tabular} \vspace{4mm}

\noindent Causes execution to be aborted\index{exit}\index{aborted} 
immediately. The string will be printed in the output. This can be used to 
indicate where \FORM\ ran into the exit statement. \vspace{10mm}

%--#] exit : 
%--#[ extrasymbols :

\section{extrasymbols}
\label{substaextrasymbols}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & extrasymbols,array\textbar{}vector\textbar{}underscore,name;
\\ See also & ToPolynomial (\ref{substatopolynomial}), FromPolynomial 
(\ref{substafrompolynomial}), ArgToExtraSymbol (\ref{substaargtoextrasymbol}) 
\\& and extra symbols 
(\ref{sect-extrasymbols}).
\end{tabular} \vspace{4mm}

\noindent Starting with version 4.0 of \FORM{} some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization~(\ref{substafactarg}) (which uses the topolynomial facilities 
automatically) and output simplification (see the Format 
statement \ref{substaformat}).
The ToPolynomial statement\index{topolynomial} takes each term, looks for 
objects that are not symbols to positive powers and replaces them by 
symbols. If the object has been encountered before the same symbol will be 
used, otherwise a new symbol will be defined. The object represented by the 
`extra symbol'\index{extra symbols} is stored internally and can be printed 
if needed with the \%X option in the \#write instruction (\ref{prewrite}). 
The representation of the extra symbols is by default the name Z followed 
by a number and an underscore character. If another name is desired this 
should be specified in an `ExtraSymbols' statement. The name given may 
contain only alphabetic characters! Because some compilers do not like the 
underscore character, there is an alternative notation for the extra 
symbols. This is just for cosmetic reasons and one cannot feed these 
symbols into the compiler this way. This is with an array notation. The 
statement
\begin{verbatim}
   ExtraSymbols,array,Ab;
\end{verbatim}
would cause the second extra symbol to be printed as {\tt Ab(2)}. The total 
number of defined extra symbols is given by the built in symbol 
extrasymbols\_.
The option vector in the ExtraSymbols statement is identical to the option 
array and the option underscore reverts the notation back to the default 
notation with the trailing underscore.
\vspace{10mm}

%--#] extrasymbols : 
%--#[ factarg :

\section{factarg}
\label{substafactarg}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & factarg options \verb:{:{\tt<}name of function/set{\tt>}
                [{\tt<}argument specifications{\tt>}]\verb:}:;
\\ See also & splitarg (\ref{substasplitarg})
\end{tabular} \vspace{4mm}

\noindent Splits\index{factarg} the indicated function\index{function 
arguments} arguments into individual factors. The argument specifications 
are as in the splitarg\index{splitarg} statement (see 
\ref{substasplitarg}). There are a few extra options:

\leftvitem{2cm}{(0)}
\rightvitem{14cm}{Eliminates the coefficient\index{coefficient} of the term 
in the argument. Similar to Normalize,(0),....}

\leftvitem{2cm}{(1)}
\rightvitem{14cm}{The coefficient of the term and its sign are pulled out 
separately.}

\leftvitem{2cm}{(-1)}
\rightvitem{14cm}{The coefficient is pulled out with its sign.}

\noindent In the case of the above options only the coefficient is treated. 
When these options are not used the whole term is treated as in:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_FactArg_1)
% TODO: On OldFactArg
\begin{verbatim}
    Symbols a,b,c;
    CFunctions f,f1,f2,f3;
    Local F = f(-3*a*b)+f(3*a*b)
             +f1(-3*a*b)+f1(3*a*b)
             +f2(-3*a*b)+f2(3*a*b)
             +f3(-3*a*b)+f3(3*a*b);
    FactArg,f;
    Factarg,(0),f1;
    Factarg,(1),f2;
    Factarg,(-1),f3;
    Print;
    .end

   F =
      f(a,b,-1,3) + f(a,b,3) + 2*f1(a*b) + f2(a*b,-1,3) + f2(a*b,3)
      + f3(a*b,-3) + f3(a*b,3);
\end{verbatim}
When no extra options are used, starting with version 4.0, the whole 
argument is factorized over the rationals. This means that
\begin{verbatim}
    f(x^2+2*x*y+y^2) --> f(y + x,y + x,1)
\end{verbatim}
It should be noticed that \FORM{} can although the internal algorithms can
only factorize expressions with numbers and symbols, \FORM{} redefines all
non-symbol objects temporarily into symbols and at the end substitutes them 
back. This is done with a mechanism that is similar to that of the 
ToPolynomial statement.

See also the On OldfactArg; and Off OldFactArg statements for a 
compatibility mode with versions before version 4.0.
\vspace{10mm}

%--#] factarg : 
%--#[ factdollar :

\section{factdollar}
\label{substafactdollar}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & factdollar {\tt<}name of dollar variable{\tt>};
\\ See also & the chapter on polynomials~\ref{polynomials}.
\end{tabular} \vspace{4mm}

\noindent The FactDollar statement will factorize a dollar expression. If 
the dollar expression was already factorized the old factors will be 
removed first. Unlike expressions (see \ref{substafactorize}) where only 
either the expanded or the factorized version exists, with dollar 
expressions we have both versions simultaneously. This means that one can 
refer to the complete dollar in its unfactorized form and its factors. The 
factors are indicated between braces as in \verb:$x[1]: which would be the 
first factor. The number of factors of \verb:$x: is given by \verb:$x[0]:. 
One can also obtain the number of factors of a dollar variable with the 
numfactors\_ function (see \ref{funnumfactors}).

\noindent The index indicating the number of the factor can be a nonzero 
integer, no greater than the number of factors, or (a factor of) a dollar 
variable that evaluates into such a number. Composite expressions are not 
allowed. They should be worked out first in a separate dollar variable, 
after which this dollar variable can then be used as a factor indicator.
\vspace{10mm}

%--#] factdollar : 
%--#[ factorize :

\section{factorize}
\label{substafactorize}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & factorize \verb:{:{\tt<}name of expression(s){\tt>}\verb:}:;
\\ See also & the chapter on polynomials~\ref{polynomials}.
\end{tabular} \vspace{4mm}

\noindent If no expressions are mentioned all expressions will be affected 
by the action of this statement. One may exclude certain expressions with 
the nfactorize statement (see \ref{substanfactorize}). If one or more 
expressions are mentoned they will be added to the list of expressions that 
will be affected.

\noindent The statement causes the output expression(s) that is/are marked 
as such to be factorized after they have been processed and already written 
to the output. This means that each expression, after having been written, 
is read again and factorized. Then the factorized result is written over 
the original output. After that \FORM{} will start executing the statements of 
the current module on the next expression, sort it, write it to output, and 
if necessary read it again and factorize it.

\noindent Expressions never exists in two varieties as the dollar variable 
that have been factorized. It is either unfactorized (default) or 
factorized. An expression remains factorized until an UnFactorize 
statement is encountered that mentions that this expression should be 
brought to unfactorized representation (see also 
UnFactorize~\ref{substaunfactorize} and 
NunFactorize~\ref{substanunfactorize}).

\noindent One should realize that factorization of complicated expressions 
can be a rather costly operation.

\vspace{10mm}

%--#] factorize : 
%--#[ fill :

\section{fill}
\label{substafill}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & fill {\tt<}tableelement{\tt>} = {\tt<}expression{\tt>} [,{\tt<}moreexpressions{\tt>}];
\\ See also & table (\ref{substatable}), 
                fillexpression (\ref{substafillexpression}),
                printtable (\ref{substaprinttable})
\end{tabular} \vspace{4mm}

\noindent The standard\index{fill} way to define elements of a 
table\index{table}. In the left hand 
side one specifies the table element without the extra function arguments 
that could potentially occur (see \ref{substatable}). In the right hand 
side one specifies what the table element should be substituted by. 
Example:
\begin{verbatim}
    Table tab(1:2,1:2,x?);
    Fill tab(1,1) = x+y;
    Fill tab(2,1) = (x+y)^2;
    Fill tab(1,2) = tab(1,1)+y;
    Fill tab(2,2) = tab(2,1)+y^2;
\end{verbatim}
The first fill statement is a bit like a continuous attempt to try the 
substitution
\begin{verbatim}
    id  tab(1,1,x?) = x+y;
\end{verbatim}
The last two fill statements show that one could use the table 
recursively\index{recursively}. 
If a real loop occurs the program may terminate due to
stack\index{stack overflow} overflow.

\noindent It is possible to define several table elements in one statement. 
In that case the various elements are separated by commas. The last index 
is the first one to be raised. This means that in the above example one 
could have written:
\begin{verbatim}
    Table tab(1:2,1:2,x?);
    Fill tab(1,1) = x+y,tab(1,1)+y,(x+y)^2,tab(2,1)+y^2;
\end{verbatim}\vspace{10mm}

\noindent One warning\index{warning} is called for. One should avoid using 
expressions in the right hand side of fill statements:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Fill_1)
\begin{verbatim}
    Table B(1:1);
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    Drop dummy;
    .sort
    Local F = B(1);
    Print;
    .end
\end{verbatim}
In the example a crash will result, because when we use the table element 
the expression dummy doesn't exist anymore. In a fill statement the r.h.s. 
is not expanded. Hence it keeps the reference to the expression dummy. When 
the table element is used the reference to the expression dummy is inserted 
and expanded. Hence one obtains the contents of dummy that exist at the 
moment of use. This is illustrated in the following example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Fill_2)
\begin{verbatim}
    Table B(1:1);
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    .sort
    Local F = B(1);
    Print;
    .sort
    Drop;
    .sort
    Local dummy = 2;
    .sort
    Local F = B(1);
    Print;
    .end
\end{verbatim}
The final value of F will be 2, not 1.

\noindent A way to get around this problem is to force the evaluation of 
the table definition by using dollar\index{dollar} 
variables\index{variable!dollar}:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Fill_3)
\begin{verbatim}
    Table B(1:1);
    Local dummy = 1;
    .sort
    #$value = dummy;
    Fill B(1) = `$value';
    Drop dummy;
    .sort
    Local F = B(1);
    Print;
    .end
\end{verbatim}
Here we use the character representation of the contents of the dollar 
variable to obtain an expression that doesn't need any further evaluation. 
If we would put
\begin{verbatim}
    fill B(1) = $value;
\end{verbatim}
a reference to the dollar variable would be inserted and it would only be 
evaluated at use again. In principle this could cause similar problems.

\noindent Not dropping the expression dummy can sometimes give the correct 
result, but is potentially still unsafe. 
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Fill_4)
\begin{verbatim}
    Table B(1:1);
    Local u = 2;
    Local dummy = 1;
    .sort
    Fill B(1) = dummy;
    Drop dummy;
    .sort
    Local v = 5;
    Local F = B(1);
    Print;
    .end
\end{verbatim}
Here the answer will be 5, because after u has been dropped the expressions 
will be renumbered. Hence now dummy becomes the first expression, and 
eventually v becomes the second expression. The references in the table 
elements are not renumbered. Hence the r.h.s.\ of B(1) keeps pointing at the 
second expression, which at the moment of application has the value 5. One 
can see now also why the original example crashes. First dummy was the 
first expression and at the moment of application F is the first (existing) 
expression. Hence the substitution of B(1) causes a self reference and 
hence an infinite loop. Eventually some buffer will 
overflow\index{overflow}.
\vspace{10mm}

%--#] fill : 
%--#[ fillexpression :
 
\section{fillexpression}
\label{substafillexpression}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & fillexpression {\tt<}table{\tt>} = {\tt<}expression{\tt>}({\tt<}x1{\tt>},...,{\tt<}xn{\tt>});
\\     & fillexpression {\tt<}table{\tt>} = {\tt<}expression{\tt>}({\tt<}funname{\tt>});
\\ See also & table (\ref{substatable}), 
                fill (\ref{substafill}) and the table\_ function 
(\ref{funtable})
\end{tabular}\vspace{4mm}

\noindent Used\index{fillexpression} to dynamically\index{dynamical loading}
load\index{loading dynamically} a table\index{table} during runtime. When 
there are n symbols (here called x1 to xn) it is assumed that the table is 
n-dimensional. The expression must previously have been bracketed in these 
symbols and each of the brackets\index{brackets} has the effect of a 
fill\index{fill} statement in which the powers of the x1 to xn refer to the 
table elements. Brackets that do not have a corresponding table element are 
skipped.

\noindent In the case that only a function name is specified the arguments 
of the function refer to the table elements.
\vspace{10mm}

%--#] fillexpression : 
%--#[ fixindex :
 
\section{fixindex}
\label{substafixindex}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & fi[xindex] \verb:{:{\tt<}number{\tt>}:{\tt<}value{\tt>}\verb:}:;
\\ See also & index (\ref{substaindex}) and chapter \ref{metric}.
\end{tabular} \vspace{4mm}

\noindent Defines \verb:d_(number,number) = value: in which number is the 
number\index{fixindex} of a fixed\index{fixed index} index\index{index} 
(hence a positive short integer with a value less than 
ConstIndex\index{constindex} (see \ref{setup}). The value should be a 
short\index{short integer} integer, i.e.\ its absolute value should be less 
than $2^{15}$ on 32\index{32 bits} bit computers and less than $2^{31}$ on 
64\index{64 bits} bit 
computers. One can define more than one fixed index in one statement. 
Before one would like to solve problems involving the choice of a metric 
with this statement, one should consult the chapter on the use of a 
metric\index{metric} 
(chapter \ref{metric}).
\vspace{10mm}

%--#] fixindex : 
%--#[ format :

\section{format}
\label{substaformat}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & fo[rmat] {\tt<}option{\tt>};
\\ See also & print (\ref{substaprint})
\end{tabular} \vspace{4mm}

\noindent Controls the format\index{format} for the 
printing\index{printing} of expressions. There is a variety of options.

\leftvitem{3.5cm}{$<$number$>$}
\rightvitem{13cm}{Output will be printed using the indicated number of 
characters per line. The default is 72. Numbers outside the range 1-255 are 
corrected to 72. Positive numbers less than 39 are corrected to 39.}

\leftvitem{3.5cm}{float\index{float}\index{format!float} \hfill \\ \null\quad{\tt[}$<$number$>${\tt]}}
\rightvitem{13cm}{Numbers are printed in floating\index{floating point} 
point notation, even though internally they remain fractions. This is 
purely cosmetic. If no number is specified the precision of the output will 
be 10 digits. If a number is specified it indicates the number of digits to 
be used for the precision.}

\leftvitem{3.5cm}{rational\index{rational}\index{format!rational}}
\rightvitem{13cm}{Output format is switched back to rational numbers (in 
contrast to floating point output). This is the default.}

\leftvitem{3.5cm}{nospaces\index{nospaces}\index{format!nospaces}}
\rightvitem{13cm}{The output is printed without the spaces that make the 
output slightly more readable. This gives a more compact output.}

\leftvitem{3.5cm}{spaces\index{spaces}\index{format!spaces}}
\rightvitem{13cm}{The output is printed with extra spaces between the terms 
and around certain operators to make it slightly more readable. This is the 
default.}
 
\leftvitem{3.5cm}{O0\index{optimize}\index{format!optimize}}
\rightvitem{13cm}{\FORM\ will turn off output optimization. See the section 
on output optimization \ref{optimization}}
 
\leftvitem{3.5cm}{O1[options]\index{optimize}\index{format!optimize}}
\rightvitem{13cm}{\FORM\ will use level 1 output optimization. See the section 
on output optimization \ref{optimization}}
 
\leftvitem{3.5cm}{O2[options]\index{optimize}\index{format!optimize}}
\rightvitem{13cm}{\FORM\ will use level 2 output optimization. See the section 
on output optimization \ref{optimization}}
 
\leftvitem{3.5cm}{O3[options]\index{optimize}\index{format!optimize}}
\rightvitem{13cm}{\FORM\ will use level 3 output optimization. See the section 
on output optimization \ref{optimization}.}

\leftvitem{3.5cm}{fortran\index{fortran}\index{format!fortran}}
\rightvitem{13cm}{The output is printed in a way that is readable by a 
fortran compiler. This includes continuation characters and the splitting 
of the output into blocks of no more than 15 continuation lines. This 
number can be changed with the setup parameter ContinuationLines (see 
\ref{setup}). In addition dotproducts are printed with the `dotchar' 
in the place of the period between the vectors. This dotchar can be set in 
the setup file (see \ref{setup}). Its default is the underscore character.}

\leftvitem{3.5cm}{doublefortran\index{doublefortran}\index{format!doublefortran}}
\rightvitem{13cm}{Same as the fortran mode, but fractions are printed with 
double floating point numbers, because some compilers convert numbers like 
1.\ into 1.E0. With this format \FORM\ will force double precision by using 
1.D0.}

\leftvitem{3.5cm}{quadruplefortran\index{quadruplefortran}\index{format!quadruplefortran}}
\rightvitem{13cm}{Same as the fortran mode, but fractions are printed with 
quadruple floating point numbers, because some compilers convert numbers like 
1.\ into 1.E0. With this format \FORM\ will force quadruple precision by using 
1.Q0.}

\leftvitem{3.5cm}{quadfortran\index{quadfortran}\index{format!quadfortran}}
\rightvitem{13cm}{Same as quadruplefortran.}

\leftvitem{3.5cm}{fortran90\index{fortran90}\index{format!fortran90}}
\rightvitem{13cm}{Similar to the fortran option, but prints the 
continuation lines according to the syntax of Fortran 90. If the fortran90 
option is followed by a comma and a string that does not contain white space 
or other comma's, this string is attached to all numbers in coefficients of 
terms. Example: \hfill \\
{\tt\ \ \ \ \ \ Format Fortran90,.0\_ki;} \hfill \\
%\begin{verbatim}
%   Format Fortran90,.0_ki;
%\end{verbatim}
which would give in the printout: \hfill \\
{\tt\ \ \ \ \ \ +23.0\_ki/32.0\_ki*a**2\& } \hfill \\
{\tt\ \ \ \ \&\ +34.0\_ki/1325.0\_ki*a**3} \hfill \\
%\begin{verbatim}
%       +23.0_ki/32.0_ki*a**2&
%     & +34.0_ki/1325.0_ki*a**3
%\end{verbatim}
When there is no string attached it defaults to a period as in the regular 
Fortran option.
}

\leftvitem{3.5cm}{C\index{C}\index{format!C}}
\rightvitem{13cm}{Output will be C compatible. The
exponent\index{exponent operator} operator ($\wedge$) is represented by the 
function pow\index{pow}. It is the responsibility of the user that this 
function will be properly defined. Dotproducts are printed with the 
`dotchar'\index{dotchar} in the place of the period between the vectors. 
This dotchar can be set in the setup file (see \ref{setup}). Its default is 
the underscore\index{underscore character} character.}

\leftvitem{3.5cm}{maple\index{maple}\index{format!maple}}
\rightvitem{13cm}{Output will be as much as possible compatible with Maple 
format. It is not guaranteed that this is perfect.}

\leftvitem{3.5cm}{mathematica\index{mathematica}\index{format!mathematica}}
\rightvitem{13cm}{Output will be as much as possible compatible with 
Mathematica format. It is not guaranteed that this is perfect.}

\leftvitem{3.5cm}{reduce\index{reduce}\index{format!reduce}}
\rightvitem{13cm}{Output will be as much as possible compatible with 
Reduce format. It is not guaranteed that this is perfect.}

\noindent The last few formats have not been tried out extensively. The 
author is open for suggestions.
 
\leftvitem{3.5cm}{normal\index{normal}\index{format!normal}}
\rightvitem{13cm}{Will return to the regular \FORM\ formatting mode.}

\noindent If the statement has no arguments the formatting will be reset to 
the mode it was in when the program started.\vspace{4mm}

%\leftvitem{3.5cm}{}
%\rightvitem{13cm}{}

%\leftvitem{3.5cm}{}
%\rightvitem{13cm}{}





\vspace{10mm}

%--#] format : 
%--#[ frompolynomial :

\section{frompolynomial}
\label{substafrompolynomial}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & frompolynomial
\\ See also & factarg (\ref{substafactarg}), ToPolynomial 
(\ref{substatopolynomial}) and ExtraSymbols (\ref{substaextrasymbols},
\ref{sect-extrasymbols}).
\end{tabular} \vspace{4mm}

\noindent Starting with version 4.0 of \FORM{} some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization~(\ref{substafactarg}) and output simplification (still to be 
implemented). Whereas the ToPolynomial statement takes each term, looks for objects 
that are not symbols to positive powers and replaces them by symbols the 
FromPolynomial does the opposite: it replaces the newly defined extra 
symbols and replaces them back by their original meaning.
\vspace{10mm}

%--#] frompolynomial : 
%--#[ functions :
 
\section{functions}
\label{substafunctions}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & f[unctions] {\tt<}list of functions to be declared{\tt>}; \\
See also & cfunctions (\ref{substacfunctions}), 
           tensors (\ref{substatensors}),
           ntensors (\ref{substantensors}), \\ &
           table (\ref{substatable}),
           ntable (\ref{substantable}),
           ctable (\ref{substactable})
\end{tabular} \vspace{4mm}

\noindent Used to declare one or more functions\index{functions}. The functions declared 
with this statement will be noncommuting\index{noncommuting}. For 
commuting\index{commuting} functions one 
should use the cf[unctions] statement (see \ref{substacfunctions}). 
Functions can have a number of properties that can be set in the 
declaration. This is done by appending the options to the name of the 
function. These options are:

\leftvitem{4.1cm}{name{\hash}r}
\rightvitem{12cm}{The function is considered to be a real\index{real} function (default).}

\leftvitem{4.1cm}{name{\hash}c}
\rightvitem{12cm}{The function is considered to be a complex\index{complex} function. This means 
that internally two spaces are reserved. One for the variable name and one 
for its complex conjugate name{\hash}.}

\leftvitem{4.1cm}{name{\hash}i}
\rightvitem{12cm}{The function is considered to be imaginary\index{imaginary}.}

\leftvitem{4.1cm}{name(s[ymmetric])}
\rightvitem{12cm}{The function is totally symmetric\index{symmetric}. This means that during 
normalization {\FORM} will order the arguments according to its internal 
notion of order by trying permutations. The result will depend on the order 
of declaration of variables.}

\leftvitem{4.1cm}{name(a[ntisymmetric])}
\rightvitem{12cm}{The function is totally antisymmetric\index{antisymmetric}. This means that 
during normalization {\FORM} will order the arguments according to its 
internal notion of order and if the resulting permutation of arguments is 
odd the coefficient of the term will change sign. The order will depend on 
the order of declaration of variables.}

\leftvitem{4.1cm}{name(c[yclesymmetric])}
\rightvitem{12cm}{The function is cycle\index{cycle symmetric} 
symmetric\index{symmetric!cycle} in all its arguments. 
This means that during normalization {\FORM} will order the arguments 
according to its internal notion of order by trying cyclic permutations. 
The result will depend on the order of declaration of variables.}

\leftvitem{4.1cm}{name(r[cyclesymmetric)

name(r[cyclic])

name(r[eversecyclic])}
\rightvitem{12cm}{The function is reverse\index{reverse cycle symmetric} 
cycle symmetric\index{symmetric!reverse cycle} in all its arguments. This 
means that during normalization {\FORM} will order the arguments according 
to its internal notion of order by trying cyclic permutations and/or a 
complete reverse order of all arguments. The result will depend on the 
order of declaration of variables.}

\leftvitem{4.1cm}{name<number

name<=number

name>number

name>=number}
\rightvitem{12cm}{The function has a restriction on the number of 
arguments. If the number of arguments of an occurrence of the function is 
not fulfilling the condition during normalization {\FORM} will set the term 
equal to zero.}\vspace{2mm}

\noindent The complexity properties, the symmetric properties and the 
number of arguments restrictions can be 
combined. In that case the complexity properties should come first and the 
argument restrictions should come last as in
\begin{verbatim}
    Function f1#i(symmetric)>=4<8;
    Function f1#i<=8;
\end{verbatim}
\vspace{10mm}

%--#] functions : 
%--#[ funpowers :

\section{funpowers}
\label{substafunpowers}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & funpowers {\tt<}on/off{\tt>};
\\ See also & on (\ref{substaon}), off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent This statement\index{funpowers} is obsolete\index{obsolete}. The 
user should try to use the funpowers option of the on\index{on} (see 
\ref{substaon}) or the off\index{off} (see \ref{substaoff}) statements. 
\vspace{10mm}

%--#] funpowers : 
%--#[ gfactorized :

\section{gfactorized}
\label{substagfactorized}

\noindent \begin{tabular}{ll}
Type & Definition statement\\
Syntax & g[lobal]factorized {\tt<}option{\tt>};
\\ See also & the chapter on polynomials~\ref{polynomials}, the 
factorize statement~\ref{substafactorize} and the LocalFactorized \\ &
statement~\ref{substalfactorized}.\hfill
\end{tabular}
\smallskip

\noindent The syntax is like the syntax of the LocalFactorized (or 
LFactorized) statement~\ref{substalfactorized}. The only difference is that 
now the expression defined by the statement will become a global 
expression (see the Global statement~\ref{substaglobal}).
\vspace{10mm}

%--#] gfactorized : 
%--#[ global :

\section{global}
\label{substaglobal}

\noindent \begin{tabular}{ll}
Type & Definition statement\\
Syntax & g[lobal] {\tt<}name{\tt>} = {\tt<}expression{\tt>}; \\
       & g[lobal] {\tt<}names of expressions{\tt>};
\\ See also & local (\ref{substalocal})
\end{tabular} \vspace{4mm}

\noindent Used to define a global\index{global} 
expression\index{expression}. A global expression is an expression that 
remains active until the first .store\index{.store} instruction. At that 
moment it is stored into the `storage file'\index{storage 
file}\index{file!storage} and stops being manipulated. After this it can 
still be used in the right hand side of expressions and id\index{id} 
statements (see \ref{substaidnew}). Global expressions that have been put 
in the storage file can be saved to a disk file\index{file!disk} with the 
save statement (see \ref{substasave}) for use in later programs.

\noindent There are two versions of the global statement. In the first the 
expression is defined and filled with a right hand side expression. The left 
hand side and the right hand side are separated by an = sign. In this case 
the expression can have arguments which will serve as
dummy\index{dummy arguments} arguments after the global expression has been 
stored with a .store instruction. Note that this use of arguments can often 
be circumvented with the replace\_ function (see \ref{funreplace}) as in
\begin{verbatim}
    Global F(a,b) = (a+b)^2;
    .store
    Local FF = F(x,y);
    Local GG = F*replace_(a,x,b,y);
\end{verbatim}
because both definitions give the same result.

\noindent The second version of the global statement has no = sign and no 
right hand side. It can be used to change a local\index{local} expression 
into a global expression. \vspace{10mm}

%--#] global : 
%--#[ goto :

\section{goto}
\label{substagoto}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & go[to] {\tt<}label{\tt>}; \\
See also & label (\ref{substalabel})
\end{tabular} \vspace{4mm}

\noindent Causes\index{goto} processing to proceed at the indicated 
label\index{label} statement 
(see \ref{substalabel}). This label statement must be in the same module. 
\vspace{10mm}

%--#] goto : 
%--#[ hide :

\section{hide}
\label{substahide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & hide; \\
       & hide {\tt<}list of expressions{\tt>};
\\ See also & nhide (\ref{substanhide}),
              unhide (\ref{substaunhide}),
              nunhide (\ref{substanunhide}),
              pushhide (\ref{substapushhide}),
              pophide (\ref{substapophide})
\end{tabular} \vspace{4mm}

\noindent In the first variety this statement marks all currently active 
expressions for being put in hidden\index{hide} storage. In the second variety it marks 
only the specified active\index{active expressions} expressions as such. \vspace{4mm}

\noindent If an expression is marked for being hidden, it will be copied to 
the `hide\index{hide file} file'\index{file!hide}, a storage which is 
either in memory or on file depending on the combined size of all 
expressions being hidden. If this size exceeds the size of the setup 
parameter scratchsize\index{scratchsize} (see \ref{setup}) the storage will 
be on file. If it is less, the storage will be in memory. An expression 
that has been hidden is not affected by the statements in the modules as 
long as it remains hidden, but it can be used inside other expressions in 
the same way skipped\index{skipped expressions} expressions (see 
\ref{substaskip}) or active expressions can be used. In particular all its 
bracket\index{bracket} information (see \ref{substabracket}) is retained 
and can be accessed, including possible bracket\index{bracket index} 
indexing. \vspace{4mm}

\noindent The hide mechanism is particularly useful if an expression is not 
needed for a large number of modules. It has also advantages over the 
storing of global expressions after a .store\index{.store} instruction (see 
\ref{instrstore}), because the substitution of global expressions is slower 
(name definitions may have changed and have to be checked) and also a 
possible bracket index is not maintained by the .store instruction. 
\vspace{4mm}

\noindent Expressions can be returned from a hidden status into active 
expressions with the unhide\index{unhide} statement (see 
\ref{substaunhide}). One might want to consult the nhide\index{nhide} 
statement (\ref{substahide}) as well. \vspace{4mm}

\noindent When an expression is marked to be hidden it will remain just 
marked until execution starts in the current module. When it is the turn of 
the expression to be executed, it is copied to the hide file instead. 
\vspace{4mm}

\noindent Note that a .store instruction will simultaneously remove all 
expressions from the hide system. \vspace{10mm}

%--#] hide : 
%--#[ identify :

\section{identify}
\label{substaidentify}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & id[entify] [{\tt<}options{\tt>}] {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & also (\ref{substaalso}),
              idnew (\ref{substaidnew}),
              idold (\ref{substaidold})
\end{tabular}\vspace{4mm}

\noindent The statement\index{id}\index{identify} tries to match the 
pattern\index{pattern}. If the pattern matches one or more times, it will 
be replaced by the expression in the r.h.s.\ taking the possible 
wildcard\index{wildcard} substitutions into account. For the description of 
the patterns, see chapter \ref{pattern}.

\noindent The options are \vspace{1mm}

\lefttabitem{multi\index{multi}}
\tabitem{This option is for combinations of symbols and dotproducts only 
and it does not use wildcard powers. \FORM\ determines how many times the 
pattern fits in one pattern matching action. Then the r.h.s.\ is substituted 
to that power. It is the default for these kinds of patterns.}

\lefttabitem{many\index{many}}
\tabitem{This is the default for patterns that contain other objects 
than symbols and dotproducts. The pattern is matched and taken out. Then 
\FORM\ tries again to match the pattern in the remainder of the term. This 
is repeated until there is no further match. Then for each match the r.h.s. 
is substituted (with its own wildcard substitutions).}

\lefttabitem{select\index{select}}
\tabitem{This option should be followed by one or more sets\index{set}. After 
the sets the pattern can be specified. The pattern will only be substituted 
if none of the objects mentioned in the sets will be left after the pattern 
has been taken out. This holds only for objects 'at ground level'; i.e.\ the 
pattern matcher will not look inside function arguments for this. Note 
that this is a special case of the option 'only'.}

\lefttabitem{once\index{once}}
\tabitem{The pattern is matched only once, even if it occurs more than once 
in the term. The first match that \FORM\ encounters is taken. When wildcards 
are involved, this may depend on the order of declaration of variables. It 
could also be installation dependent. Also the setting of 
properorder\index{properorder} (see \ref{substaon} and \ref{substaoff}) 
could be relevant. Try to write programs in such a way that the outcome 
does not depend on which match is taken.}

\lefttabitem{only\index{only}}
\tabitem{The pattern will match only if there is an exact match in 
the powers of the symbols and dotproducts present.}

\lefttabitem{ifmatch$-\!\!>$\index{ifmatch}}
\tabitem{This option should be followed by the name (or number) of a 
label\index{label}. If the pattern matches, the replacement will be made 
after which the execution continues at the label.}

\lefttabitem{ifnomatch$-\!\!>$\index{ifmatch}}
\tabitem{This option should be followed by the name (or number) of a 
label\index{label}. If the pattern does not match, 
execution continues at the label.}

\lefttabitem{disorder\index{disorder}}
\tabitem{This option is used for products of 
noncommuting\index{noncommuting} functions\index{functions!noncommuting} or 
tensors\index{tensors!noncommuting}. The match will only take place if the 
order of the functions in the match is different from what \FORM\ would have 
made of it if the functions would be commuting\index{commuting}. Hence if 
the functions in the term are in the order that \FORM\ would give them if 
they would be commuting (which depends on the order of declaration) there 
will be no match. This can be rather handy when using wildcards as in {\tt 
F(a?)*F(b?)}.}

\lefttabitem{all\index{all}}
\tabitem{This option is rather special in that it generates all possible 
matches one by one. Normally, when there are many possible matches, \FORM\ 
takes the first one it encounters. In the case of the all option it will 
run through all possible matches and produce all of them. There are however 
severe restrictions. First of all, other options are not allowed 
simultaneously, although ifmatch$-\!\!>$ and ifnomatch$-\!\!>$ are allowed 
because technically they are no options that concern the pattern matching. 
In addition it is not allowed to be in an idold/also statement, and it 
cannot be followed by such a statement. Most severely: it can have only 
functions in the left hand side. These functions can have all kinds of 
arguments, but outside the functions symbols, vectors, dotproducts etc.\ are 
not allowed. This is due to the fact that the backtracking when a wildcard 
combination fails, does not include such objects and it is this 
backtracking mechanism that is used to generate all matches. For the 
purpose of the all option tensors and unsubstituted tables count as 
functions. It should also be known that the all option cannot be used in 
the if(match()) construction. It would not make sense there anyway.}

\noindent Example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Identify_1)
\begin{verbatim}
    Vector Q,p1,...,p5,q1,...,q5;
    Cfunction V(s),replace;
    Format 60;
    *   This is a t1 topology:
    L   F = V(Q,p1,p4)*V(p1,p2,p5)*
            V(p2,p3,Q)*V(p3,p4,p5);
    $t = term_;
    id,all,$t*replace_(<p1,p1?>,...,<p5,p5?>) =
         $t*replace(<p1,q1>,...,<p5,q5>);
    Print +s;
    ModuleOption noparallel; * suppresses noparallel warning with TFORM
    .end

   F =
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p1,q1,p2,q2,p3,q3,p4,q4,p5,q5)
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p2,q1,p1,q2,p4,q3,p3,q4,p5,q5)
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p3,q1,p4,q2,p1,q3,p2,q4,p5,q5)
       + V(Q,p1,p4)*V(Q,p2,p3)*V(p1,p2,p5)*V(p3,p4,p5)*
      replace(p4,q1,p3,q2,p2,q3,p1,q4,p5,q5)
      ;
\end{verbatim}
This program produces all renumberings of the momenta in the t1 topology 
that produce the same topology. The interesting thing here is that one does 
not have to know the topology to produce all topologically equivalent 
terms.

There are two options in the id,all statement: \hfill \\
\lefttabitem{all(n[ormalize])}
\tabitem{Here the final answer is divided by the number of matches. In the 
example above that would be 4.}
\lefttabitem{all($<$number$>$)}
\tabitem{The number between the parentheses will be the maximum number of 
matches allowed. This means that once this number is reached, no further 
matches are produced.}
\vspace{10mm}

%--#] identify : 
%--#[ idnew :

\section{idnew}
\label{substaidnew}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & idn[ew] [{\tt<}options{\tt>}] {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify}),
              also (\ref{substaalso}),
              idold (\ref{substaidold})
\end{tabular} \vspace{4mm}

\noindent This statement\index{idnew} and its options are completely 
identical to the regular id\index{id} or identify\index{identify} statement 
(see \ref{substaidentify}). \vspace{10mm}

%--#] idnew : 
%--#[ idold :

\section{idold}
\label{substaidold}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & ido[ld] [{\tt<}options{\tt>}] {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify}),
              also (\ref{substaalso}),
              idnew (\ref{substaidnew})
\end{tabular}\vspace{4mm}

\noindent This statement\index{idold} and its options are completely 
identical to the regular also\index{also} statement (see \ref{substaalso}). 
The options are described with the id\index{id} or identify\index{identify} 
statement (see \ref{substaidentify}).
\vspace{10mm}

%--#] idold : 
%--#[ if :
 
\section{if}
\label{substaif}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & if ( {\tt<}condition{\tt>} ); \\
       & if ( {\tt<}condition{\tt>} ) {\tt<}executable statement{\tt>}
\\ See also & elseif (\ref{substaelseif}),
              else (\ref{substaelse}),
              endif (\ref{substaendif})
\end{tabular} \vspace{4mm}

\noindent Used\index{if} for executing parts of code only when certain 
conditions\index{condition} are met. Works together with the 
else\index{else} statement (see \ref{substaelse}), the elseif\index{elseif} 
statement (see \ref{substaelseif}) and the endif\index{endif} statement 
(see \ref{substaendif}). There are two versions. In the first the if 
statement must be accompanied by at least an endif statement. In that case 
the statements between the if statement and the endif statement will be 
executed if the condition is met. It is also possible to use elseif and 
else statements to be more flexible. This is done in the same way as in 
almost all computer languages.

\noindent In the second form the if statement does not terminate with a 
semicolon\index{semicolon}. It is followed by a single regular statement. 
No endif statement should be used. The single statement will be executed if 
the condition is met.

\noindent The condition in the if statement should be enclosed by 
parentheses. Its primary components are:

\leftvitem{3.5cm}{count()\index{count}}
\rightvitem{13cm}{Returns an integer power counting value for the current 
term. Should have arguments that come in pairs. The first element of the 
pair is a variable. The second is its integer weight\index{weight}. The 
types of variables that are allowed are symbols, dotproducts, functions, 
tensors, tables and vectors. The weights can be positive as well as 
negative. They have to be short integers (Absolute value $< 2^{15}$ on 
32\index{32 bits} bit computers and $< 2^{31}$ on 64\index{64 bits} bit 
computers). The vectors can have several options appended to their name. 
This is done by putting a + after the name of the vector and have this 
followed by one or more of the following letters:

\noindent \begin{tabular}{ll}
v & Loose vectors with an index are taken into account. \\
d & Vectors inside dotproducts are taken into account.  \\
f & Vectors inside tensors are taken into account. \\
?set &
\begin{minipage}[t]{11cm}{The set should be a set of functions. Vectors inside 
the functions that are members of the set are taken into account. It is 
assumed that those functions are linear in the given vector}\end{minipage}
\end{tabular} \vspace{1mm}

When no options are specified the result is identical to +vfd.}

\leftvitem{3.5cm}{match()\index{match}}
\rightvitem{13cm}{The argument of the match condition can be any left hand 
side of an id statement, including options as once\index{once}, 
only\index{only}, multi\index{multi}, many\index{many} and 
select\index{select} (see \ref{substaidnew}). The id of the id statement 
should not be included. \FORM\ will invoke the pattern\index{pattern matcher} 
matcher and see how many times the pattern matches. This number is 
returned. In the case of once or only this is of course at most one.}

\leftvitem{3.5cm}{expression()\index{expression}}
\rightvitem{13cm}{The argument(s) of this condition is/are a list of 
expressions. In the case that the current term belongs to any of the given 
expressions the return value is 1. If it does not belong to any of the 
given expressions the return value is 0.}

\leftvitem{3.5cm}{occurs()\index{expression}}
\rightvitem{13cm}{The argument(s) of this condition is/are a list of 
variables. In the case that any of the variables occurs inside the current 
term (including inside function arguments) the 
return value is 1. Otherwise the return value is zero.}

\leftvitem{3.5cm}{findloop()\index{findloop}}
\rightvitem{13cm}{The arguments are as in the 
replaceloop\index{replaceloop} statement (see \ref{substareplaceloop}) with 
the exception of the outfun which should be omitted. If \FORM\ detects an 
index\index{index loop} loop in the current term that fulfils the specified 
conditions the return value is 1. It is 0 otherwise.}
 
\leftvitem{3.5cm}{multipleof()\index{multipleof}}
\rightvitem{13cm}{The argument should be a positive integer. This object is 
to be compared with a number (could be obtained from a condition) and if 
this number is an integer multiple of the argument there will be a match. 
If should be obvious that such a compare only makes sense for the == and != 
operators.}

\leftvitem{3.5cm}{$<$integer$>$}
\rightvitem{13cm}{To be compared either with another number, the result of a 
condition or a multipleof object.}
 
\leftvitem{3.5cm}{coefficient\index{coefficient}}
\rightvitem{13cm}{Represents the coefficient of the current term.}

\leftvitem{3.5cm}{\$-variable}
\rightvitem{13cm}{Will be evaluated at runtime when the if statement is 
encountered. Should evaluate into a numerical value. If it does not, an 
error will result.}

\noindent All the above primary components result in numerical objects. 
Such objects can be compared to each other in structures of the type 
$<$obj1$>$ $<$operator$>$ $<$obj2$>$. The result of such a compare is 
either true (or 1) or false (or 0). The operators are:
 
\leftvitem{2cm}{$>$}
\rightvitem{14cm}{Results in true if object 1 is greater than object 2.}
 
\leftvitem{2cm}{$<$}
\rightvitem{14cm}{Results in true if object 1 is less than object 2.}
 
\leftvitem{2cm}{$=$}
\rightvitem{14cm}{Same as ==.}
 
\leftvitem{2cm}{$==$}
\rightvitem{14cm}{Results in true if both objects have the same value.}
 
\leftvitem{2cm}{$>=$}
\rightvitem{14cm}{Results in true if object 1 is greater than or equal to object 2.}
 
\leftvitem{2cm}{$<=$}
\rightvitem{14cm}{Results in true if object 1 is less than or equal to object 2.}
 
\leftvitem{2cm}{$!=$}
\rightvitem{14cm}{Results in true if object 1 does not have the same value 
as object 2.}

If the condition for true is not met, false is returned. Several of the 
above compares can be combined with logical operators. For this it is 
necessary to enclose the above compares within parentheses. This forces 
\FORM\ to interpret the hierarchy\index{hierarchy} of the operators 
properly. The extra logical operators are
 
\leftvitem{2cm}{$||$}
\rightvitem{14cm}{The or operation. True if at least one of the objects 1 
and 2 is true (or nonzero). False or zero if both are false or zero.}
 
\leftvitem{2cm}{$\&\&$}
\rightvitem{14cm}{The and operation. True if both the objects 1 
and 2 are true (or nonzero). False or zero if at least one is false or zero.}

\noindent Example:
\begin{verbatim}
    if ( ( match(f(1,x)*g(?a)) && ( count(x,1,v+d,1) == 3 ) )
         || ( expression(F1,F2) == 0 ) );
        some statements
    endif;
    if ( ( ( match(f(1,x)*g(?a)) == 0 ) && ( count(x,1,v+d,1) == 3 ) )
         || expression(F1,F2) );
        some statements
    endif;
\end{verbatim}
We see that \verb:match(): is equivalent to \verb:( match() != 0 ): and 
something similar for \verb:expression():. This shorthand\index{shorthand} 
notation can make a program slightly more readable.

{\bf Warning! } The if-statement knows only logical values as the result of 
operations. Hence the answer to anything that contains parenthesis (which 
counts as the evaluation of an expression) is either true (1) or false (0). 
Hence the object (5) evaluates to true. \vspace{10mm}

%--#] if : 
%--#[ ifmatch :

\section{ifmatch}
\label{substaifmatch}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & ifmatch$-\!\!>$ {\tt<}label{\tt>} {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement\index{ifmatch} is identical to the ifmatch option 
of the id statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   ifmatch-> ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id ifmatch-> ....
\end{verbatim}
\vspace{10mm}

%--#] ifmatch : 
%--#[ ifnomatch :

\section{ifnomatch}
\label{substaifnomatch}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & ifnomatch$-\!\!>$ {\tt<}label{\tt>} {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement\index{ifnomatch} is identical to the ifnomatch option 
of the id statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   ifnomatch-> ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id ifnomatch-> ....
\end{verbatim}
\vspace{10mm}

%--#] ifnomatch : 
%--#[ index :
 
\section{index, indices}
\label{substaindex}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & i[ndex] {\tt<}list of indices to be declared{\tt>}; \\
       & i[ndices] {\tt<}list of indices to be declared{\tt>};
\\ See also & dimension (\ref{substadimension}),
              fixindex (\ref{substafixindex})
\end{tabular} \vspace{4mm}

\noindent Declares one or more indices\index{index}\index{indices}. In the 
declaration of an index one can specify its dimension\index{dimension}. 
This is done by appending one or two options to the name of the index to be 
declared:\vspace{4mm}

\leftvitem{3.5cm}{name=dim}
\rightvitem{13cm}{The dimension is either a nonnegative integer or a 
previously declared symbol. If the dimension is zero\index{zero!dimension} 
this means that no dimension is attached to the index. The consequence is 
that the index cannot be summed over and index contractions are not 
performed for this index. If no dimension is specified the default 
dimension will be assumed (see the dimension statement 
\ref{substadimension}).}

\leftvitem{3.5cm}{name=dim:ext}
\rightvitem{13cm}{The dimension is a symbol as above. Ext is an extra 
symbol which indicates the value of dim-4. This option is useful when 
traces over gamma matrices are considered (see \ref{substatrace} and 
\ref{substatracen}).} \vspace{10mm}

%--#] index : 
%--#[ inexpression :
 
\section{inexpression}
\label{substainexpression}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & inexpression,name(s) of expression(s);
\\ See also & endinexpression~(\ref{substaendinexpression})
\end{tabular} \vspace{4mm}

\noindent The combination\index{inexpression}
\begin{verbatim}
   InExpression,expr;
       Statements;
   EndInExpression;
\end{verbatim}
is a more readable version of the construction
\begin{verbatim}
   if ( expression(expr) );
       Statements;
   endif;
\end{verbatim}
\vspace{10mm}

%--#] inexpression : 
%--#[ inparallel :

\section{inparallel}
\label{substainparallel}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & inparallel; \\
       & inparallel {\tt<}list of expressions{\tt>};
\\ See also & NotInParallel (\ref{substanotinparallel}), 
     ModuleOption (\ref{substamoduleoption})
\end{tabular} \vspace{4mm}

\noindent This statement is only active in the context of 
\TFORM\index{TFORM} and \ParFORM\index{ParFORM}. It causes 
(small) expressions to be executed side by side. Normally the terms of 
expressions are distributed over the processors and the expressions are 
executed one by one. This isn't very efficient for small expressions 
because there is a certain amount of overhead. When there are many small 
expressions, this statement can cause each expression to be executed by its 
own processor. A consequence is that the expressions now can finish in a 
semi-random order and hence may end up in the output in a order that is 
different from when this statement isn't used. The proper order is restored 
in the first module that comes after and that doesn't use this option. One 
should be careful using this statement for big expressions, because in that 
case the sorting may need sort files and the output may temporarily need 
scratch files and the simultaneous use of many files can slow execution 
down significantly.

\noindent In the case that no expressions are mentioned, all active 
expressions will be affected. When there is a list of expressions, only 
those mentioned will be affected, provided they are active. Several of 
these statements will work cumulatively. This statement doesn't affect 
expressions that are still to be defined inside the current module. If it 
is needed to affect such expressions inside the current module, one should 
use the InParallel option of the 
ModuleOption~\ref{substamoduleoption}\index{ModuleOption} 
statement. This statement works independently of the `On 
Parallel;'~\ref{substaon} and `Off Parallel;'~\ref{substaoff} statements.
\vspace{10mm}

%--#] inparallel : 
%--#[ inside :

\section{inside}
\label{substainside}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & inside {\tt<}list of \$-variables{\tt>};
\\ See also & endinside (\ref{substaendinside}) and the chapter on \$-variables 
(\ref{dollars})
\end{tabular} \vspace{4mm}

\noindent works\index{inside} a bit like the argument\index{argument} 
statement (see \ref{substaargument}) but with 
\$-variables\index{\$-variable} instead of with functions. An inside 
statement should be paired with an endinside\index{endinside} statement 
(see \ref{substaendinside}) inside the same module. The statements 
in-between will then be executed on the contents of the \$-variables that 
are mentioned. One should pay some attention to the order of the action. 
The \$-variables are treated sequentially. Hence, after the first one has 
been treated its contents are substituted by the new value. Then the second 
one is treated. If it uses the contents of the first variable, it will use 
the new value. If the first variable uses the contents of the second 
variable it will use its old value. Redefining any of the listed 
\$-variables in the range of the `inside-environment' is very dangerous. It 
is not specified what \FORM\ will do. Most likely it will be 
unpleasant\index{unpleasant}. 
\vspace{10mm}

%--#] inside : 
%--#[ insidefirst :

\section{insidefirst}
\label{substainsidefirst}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & insidefirst {\tt<}on/off{\tt>};
\\ See also & on (\ref{substaon}), off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent This statement\index{insidefirst} is obsolete\index{obsolete}. 
The user should try to use the insidefirst option of the on (see 
\ref{substaon}) or the off (see \ref{substaoff}) statements. \vspace{10mm}

%--#] insidefirst : 
%--#[ intohide :

\section{intohide}
\label{substaintohide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & intohide; \\
       & intohide {\tt<}list of expressions{\tt>};
\\ See also & hide (\ref{substahide})
\end{tabular} \vspace{4mm}

\noindent In the first variety this statement marks all currently active 
expressions for being put in hidden\index{hide} storage at the end of the 
module, after it has been processed. In the second variety it marks only 
the specified active\index{active expressions} expressions as such. 
\vspace{4mm}

\noindent The difference with the hide (\ref{substahide}) statement is 
that in the hide statement the expression is copied immediately into the 
hide system and it will not be processed in the current module, while in 
the intohide statement the expression is first processed and its final 
output in this module is sent to the hide system rather than to the regular 
scratch system. The effect is the same as not putting the intohide 
statement in the current module and putting a hide statement in the next, 
but it saves one copy operation and it is possibly a bit more economical 
with the disk space.
\vspace{4mm}

\noindent Note that a .store instruction will simultaneously remove all 
expressions from the hide system. \vspace{10mm}
%--#] intohide : 
%--#[ keep :

\section{keep}
\label{substakeep}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & keep brackets; \\
See also & bracket (\ref{substabracket}), antibracket 
     (\ref{substaabrackets}) and the chapter on brackets 
     (\ref{brackets})
\end{tabular} \vspace{4mm}

\noindent The effect\index{keep brackets}\index{keep}\index{brackets!keep} 
of this statement is that during execution of the current module the 
contents of the brackets are not considered. The statements only act on the 
`outside' of the brackets. Only when the terms are considered finished and 
are ready for the sorting are they multiplied by the contents of the 
brackets. At times this can save much computer time as complicated pattern 
matching and multiplications of function arguments with large fractions 
have to be done only once, rather than for each complete term separately 
(assuming that each bracket contains a large number of terms).

\noindent There can be some nasty side effects. Assume an expression like:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Keep_1)
\begin{verbatim}
    F = f(i1,x)*(g(i1,y)+g(i1,z));
    B  f;
    .sort
    Keep Brackets;
    sum i1;
\end{verbatim}
the result will be
\begin{verbatim}
    F = f(N1_?,x)*g(i1,y)+f(N1_?,x)*g(i1,z);
\end{verbatim}
because at the moment of summing over i1 \FORM\ is not looking inside the 
brackets and hence it never sees the second occurrence of i1. There are 
some beneficial applications of the keep statement in the 
`mincer'\index{mincer} package that comes with the \FORM\ distribution. In 
this package the most costly step was made faster by a significant factor 
(depending on the problem) due to the keep brackets statement. 
\vspace{10mm}

%--#] keep : 
%--#[ label :

\section{label}
\label{substalabel}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & la[bel] {\tt<}name of label{\tt>};
\\ See also & goto (\ref{substagoto})
\end{tabular} \vspace{4mm}

\noindent Places a label\index{label} at the current location. The name of 
the label can be any name or positive number. Control can be transferred to the 
position of the label by a goto\index{goto} statement (see 
\ref{substagoto}) or the ifmatch\index{ifmatch} option of an id statement 
(see \ref{substaidentify}). The only condition is that the goto statement 
and the label must be inside the same module. Once the module is terminated 
all existing labels are forgotten. This means that in a later module a 
label with the same name can be used again (this may not improve 
readability though but it is a good thing when third party libraries are 
used). \vspace{10mm}

%--#] label : 
%--#[ lfactorized :

\section{lfactorized}
\label{substalfactorized}

\noindent \begin{tabular}{ll}
Type & Definition statement\\
Syntax & l[ocal]factorized {\tt<}name{\tt>} = {\tt<}expression{\tt>};
\\ See also & the chapter on polynomials~\ref{polynomials} and the 
factorize statement~\ref{substafactorize}.
\end{tabular} \vspace{4mm}

\noindent Used to define a local\index{local} expression in factorized 
notation and keep it that way. The factors are recognized by multiplication 
and division signs at lowest bracket level. For the rest the expression is 
treated as a regular local expression. Example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_LFactorized_1)
\begin{verbatim}
    Symbols x,y,z;
    LocalFactorized F1 = 3*(x+y)*(y+z)*((x+z)*(2*x+1));
    LocalFactorized F2 = 3*(x+y)*(y+z)+((x+z)*(2*x+1));
    Print;
    .end

   F1 =
         ( 3 )
       * ( y + x )
       * ( z + y )
       * ( z + x + 2*x*z + 2*x^2 );

   F2 =
         ( z + 3*y*z + 3*y^2 + x + 5*x*z + 3*x*y + 2*x^2 );
\end{verbatim}
\noindent As one can see in the second expression, the plus at ground level 
makes that there is only one factor. In the first expression the last 
factor is seen as a single factor and not two factor2 because of the extra 
parentheses. Only parentheses at ground level are used to recognize 
factors. If one needs those factors anyway, one should either leave away 
those parentheses or use an extra Factorize statement to have \FORM{} 
refactorize the expression.
\vspace{10mm}

%--#] lfactorized : 
%--#[ load :

\section{load}
\label{substaload}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & loa[d] {\tt<}filename{\tt>} [{\tt<}list of expressions{\tt>}];
\\ See also & save (\ref{substasave}), delete (\ref{substadelete})
\end{tabular} \vspace{4mm}

\noindent Loads\index{load} a previously saved\index{saved file} 
file\index{file!saved} (see \ref{substasave}). If no expressions are 
specified all expressions in the file are put in the storage 
file\index{file!storage} and obtain the status of stored global 
expressions. If a list of expressions is specified all those expressions 
are loaded and possible other expressions are ignored. If a specified 
expression is not present, an error will result. If one does not know 
exactly what expressions are present in a file one could load the file 
without a list of expressions, because \FORM\ will list all expressions that 
it encountered. \vspace{10mm}

%--#] load : 
%--#[ local :
 
\section{local}
\label{substalocal}

\noindent \begin{tabular}{ll}
Type & Definition statement\\
Syntax & l[ocal] {\tt<}name{\tt>} = {\tt<}expression{\tt>}; \\
       & l[ocal] {\tt<}names of expressions{\tt>};
\\ See also & global (\ref{substaglobal})
\end{tabular} \vspace{4mm}

\noindent Used to define a local\index{local} expression. A local 
expression is an expression that will be dropped\index{drop} when a 
.store\index{.store} instruction is encountered. If this is not what is 
intended one should use global\index{global} expressions (see 
\ref{substaglobal}). The statement can also be used to change the status of 
a global expression into that of a local expression. In that case there is 
no = sign and no right hand side. \vspace{10mm}

%--#] local : 
%--#[ makeinteger :

\section{makeinteger}
\label{substamakeinteger}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & makeinteger [{\tt<}argument specifications{\tt>}] \\ &
    \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ 
 \verb:{:{\tt<}name of function/set{\tt>}
[{\tt<}argument specifications{\tt>}]\verb:}:; \\
See also & normalize (\ref{substanormalize})
\end{tabular} \vspace{4mm}

\noindent Normalizes\index{makeinteger} the indicated 
argument\index{argument} of the indicated functions(s) in such a way that 
all terms in this argument have integer 
coefficients\index{coefficients!integer} with a their greatest common 
divider being one. This still leaves the possibility that the first term of 
this argument may be negative. If this is not desired one can first 
normalize\index{normalize} the argument and then make its coefficients 
integer. The overall factor that is needed to make the coefficients like 
described is taken from the overall factor of the complete term. Example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_MakeInteger_1)
\begin{verbatim}
    S   a,b,c;
    CF  f;
    L   F = f(22/3*a+14/5*b+18/7*c);
    MakeInteger,f;
    Print +f;
    .end
   F =
      2/105*f(135*c + 147*b + 385*a);
\end{verbatim}

\noindent Note that this feature can be used to make outputs look much more 
friendly. It can be used in combination with the 
AntiBracket\index{antibracket} statement (\ref{substaabrackets}) and the 
function dum\_\index{dum\_} (\ref{fundum}) to imitate a smart extra level 
of brackets and make outputs shorter.

It is possible to introduce a scale factor when extracting the coefficient 
and multiplying it into the complete term.

\leftvitem{4cm}{MakeInteger,$\wedge<n>$,f;}
\rightvitem{12cm}{The number n must be an integer (may be negative) and if 
the coefficient that is extracted is c the whole term is multiplied by the 
factor $c^n$.}
\vspace{10mm}

%--#] makeinteger : 
%--#[ many :
 
\section{many}
\label{substamany}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & many {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement\index{many} is identical to the many option of the 
id\index{id} statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   many ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id many ....
\end{verbatim}
\vspace{10mm}

%--#] many : 
%--#[ merge :
%
\section{merge}
\label{substamerge}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & merge,functionname; \\
       & merge,once,functionname;
\\ See also & shuffle (\ref{substashuffle})
\end{tabular} \vspace{4mm}

\noindent This statement is exactly the same as the shuffle\index{shuffle} 
statement (see \ref{substashuffle}).
\vspace{10mm}
%
%--#] merge : 
%--#[ metric :

\section{metric}
\label{substametric}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & metric {\tt<}option{\tt>};
\end{tabular}
\smallskip

\noindent Remark: statement\index{metric} is inactive\index{inactive}. 
Should have no effect.
\vspace{10mm}

%--#] metric : 
%--#[ moduleoption :

\section{moduleoption}
\label{substamoduleoption}

\noindent \begin{tabular}{ll}
Type & Module control statement\\
Syntax & moduleoption {\tt<}option{\tt>}[,{\tt<}value{\tt>}];
\\ See also & polyfun (\ref{substapolyfun}),
              processbucketsize (\ref{substaprocessbucketsize}),
              dollar variables (\ref{pardollars})
\end{tabular} \vspace{4mm}

\noindent Used\index{moduleoption} to set a mode for just the current 
module. It overrides the normal setting and will revert to this normal 
setting after this module. The settings are:

\leftvitem{3.5cm}{parallel\index{moduleoption!parallel}}
\rightvitem{13cm}{Allows parallel\index{parallel} execution of the current module if all 
other conditions are right. This is the default.}

\leftvitem{3.5cm}{noparallel\index{moduleoption!noparallel}}
\rightvitem{13cm}{Vetoes parallel\index{parallel} execution of the current module.}

\leftvitem{3.5cm}{inparallel\index{moduleoption!inparallel}}
\rightvitem{13cm}{This option is more or less equivalent to the 
InParallel~\ref{substainparallel} statement. The difference is that because 
this statement comes at the end of the module, its effects include also the 
expressions that have been defined inside the current module. This is not 
the case for the InParallel statement. The InParallel option can be 
followed by the names of expressions. If no such names are present, all 
active expressions are affected. Otherwise only the expressions that are 
mentioned are affected. Once this option is mentioned no more options can 
be used inside the same ModuleOption statement. This is to avoid potential 
confusion that could arise when expressions are used with a name identical 
to the name of one of the options.}

\leftvitem{3.5cm}{notinparallel\index{moduleoption!notinparallel}}
\rightvitem{13cm}{This option is more or less equivalent to the 
NotInParallel~\ref{substanotinparallel} statement. The difference is that 
because this statement comes at the end of the module, its effects include 
also the expressions that have been defined inside the current module. This 
is not the case for the NotInParallel statement. The NotInParallel option 
can be followed by the names of expressions. If no such names are present, 
all active expressions are affected. Otherwise only the expressions that 
are mentioned are affected. Once this option is mentioned no more options 
can be used inside the same ModuleOption statement. This is to avoid 
potential confusion that could arise when expressions are used with a name 
identical to the name of one of the options.}

\leftvitem{3.5cm}{polyfun\index{moduleoption!polyfun}}
\rightvitem{13cm}{Possibly followed by the name of a 
`polyfun'\index{polyfun}. Is similar to the polyfun statement (see 
\ref{substapolyfun}) but only valid for the current module.}

\leftvitem{3.5cm}{polyratfun\index{moduleoption!polyfun}}
\rightvitem{13cm}{Possibly followed by the name of a 
`polyratfun'\index{polyratfun}. Is similar to the polyfun statement (see 
\ref{substapolyratfun}) but only valid for the current module. If there is 
second name, it refers to the inverse polyratfun. More complicated options 
of the polyratfun statement cannot be used here.}

\leftvitem{3.5cm}{processbucketsize\index{moduleoption!processbucketsize}}
\rightvitem{13cm}{Followed by a number. Similar to the 
processbucketsize\index{processbucketsize} 
statement (see \ref{substaprocessbucketsize}) but only valid for the current 
module.}

\leftvitem{3.5cm}{local\index{moduleoption!local}}
\rightvitem{13cm}{Should be followed by a list of \$-variables. Indicates 
that the contents of the indicated \$-variables\index{\$-variable} are not 
relevant once the module has been finished and neither is the term by term 
order in which the \$-variables obtain their value. In practise each 
processor\index{processor}/thread\index{thread} will work with its own copy 
of this variable.}

\leftvitem{3.5cm}{maximum\index{moduleoption!maximum}}
\rightvitem{13cm}{Should be followed by a list of 
\$-variables\index{\$-variable}. Indicates that of the contents of the 
indicated \$-variables the maximum is the only thing that is relevant once 
the module has been finished. The term by term order in which the 
\$-variables obtain their value is not relevant.}

\leftvitem{3.5cm}{minimum\index{moduleoption!minimum}}
\rightvitem{13cm}{Should be followed by a list of 
\$-variables\index{\$-variable}. Indicates that of the contents of the 
indicated \$-variables the minimum is the only thing that is relevant once 
the module has been finished. The term by term order in which the 
\$-variables obtain their value is not relevant.}

\leftvitem{3.5cm}{sum\index{moduleoption!sum}}
\rightvitem{13cm}{Should be followed by a list of 
\$-variables\index{\$-variable}. Indicates that the indicated \$-variables 
are representing a sum. The term by term order in which the \$-variables 
obtain their value is not relevant.}

\noindent The options `local', `maximum', `minimum' and `sum' are for 
parallel versions of \FORM\@. The presence of \$-variables can be a problem 
when the order of processing of the terms is not well defined. These 
options tell \FORM\ what these \$-variables are used for. In the above 
cases \FORM\ can take the appropriate action when gathering information 
from the various processors. This will allow
parallel\index{parallel execution} execution of the current module. If
\$-variables are used in a module and they are defined on a term by term
basis, the normal action of \FORM\ will be to veto parallel execution unless
it is clear that no confusion can occur. See also chapter \ref{parallel} on
the parallel version and section \ref{pardollars} on the dollar variables.\vspace{10mm}

%--#] moduleoption : 
%--#[ modulus :
 
\section{modulus}
\label{substamodulus}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & m[odulus] [option(s)] {\tt<}value{\tt>};
\end{tabular} \vspace{4mm}

\noindent Defines all calculus to be modulus\index{modulus} the given 
integer value, provided this number is positive.

% If this number is less than the 
%(installation dependent but at least 10000) maximum power for symbols and 
%dotproducts the powers of symbols and dotproducts are reduced with the 
%relation $x^{value} = x$.

\noindent The modulus calculus extends itself to 
fractions\index{fractions}. This means that if the value is not a prime 
number division by zero could result. It is the responsibility of the user 
to avoid such problems.

\noindent When the value in the modulus statement is either 0 or 1 the 
statement would be meaningless. It is used as a signal to \FORM\ that modulus 
calculus should be switched off again.

The options are
\begin{description}
\item[NoFunctions] Modulus calculus is not performed inside function 
arguments.
\item[AlsoFunctions] Modulus calculus is also performed inside function 
arguments.
\item[CoefficientsOnly] Modulus calculus is neither performed inside function 
arguments nor on powers of symbols.
\item[PlusMin] The values of numbers are reduced to the range 
$(-value+1)/2$ to $(value-1)/2$.
\item[Positive] The values of numbers are reduced to the range $0$ to 
$value-1$.
\item[NoDollars] The modulus calculus is not performed inside dollar 
variables.
\item[AlsoDollars] The modulus calculus is performed also inside dollar 
expressions.
\item[InverseTable] To speed up calculations all inverses are computed by 
means of a table. If the modulus value is very big, this table may be too 
big for the memory. That would result in an error message.
\item[NoInverseTable] No Table of Inverses is constructed. They are 
calculated whenever needed.
\item[AlsoPowers] Reduction is also used on powers of symbols with the 
relation $x^mod = x$ if mod is the given value
\item[NoPowers] No reduction on powers is done.
\item[PrintPowersOf] The proper syntax is here printpowersof(generator) in 
which generator is supposed to be a generator for calculus modulus the 
given value, which means that all numbers will be written as a power of the 
generator. If the number turns out not to be a proper generator an error 
will be given. Note that finding the powers is done by means of the 
construction of a table. Hence, if the modulus value is very big the table 
might not fit inside memory. This will result in an error message.
\end{description}
The default mode is NoFunctions, Positive, NoInverseTable, NoDollars, 
NoPowers.

The current syntax (version 4.0 and later) differs slightly from the 
previous syntax. As however there were many bugs in the old implementation 
we suspect that a slight change of the options does not inconvenience any 
many users.

%--#] modulus : 
%--#[ multi :
 
\section{multi}
\label{substamulti}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & multi {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement is identical to the multi\index{multi} option of 
the id\index{id} statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   multi ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id multi ....
\end{verbatim}
\vspace{10mm}

%--#] multi : 
%--#[ multibracket : ????????????
% 
%\section{multibracket}
%\label{substamultibracket}
%
%\noindent \begin{tabular}{ll}
%Type & Output control statement\\
%Syntax & multibracket ??????????????
%\\ See also & bracket (\ref{substabracket})
%\end{tabular} \vspace{4mm}
%
%\vspace{10mm}
%
%--#] multibracket : 
%--#[ multiply :
 
\section{multiply}
\label{substamultiply}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & mu[ltiply] [{\tt<}option{\tt>}] {\tt<}expression{\tt>};
\end{tabular} \vspace{4mm}

\noindent Statement multiplies\index{multiply} all terms by the given 
expression. It is advisable to use the options when noncommuting variables 
are involved. They are:\vspace{1mm}

\lefttabitem{left\index{multiply!left}}
\tabitem{Multiplication is from the left.}

\lefttabitem{right\index{multiply!right}}
\tabitem{Multiplication is from the right.}

\noindent There is no guarantee\index{guarantee} as to what the default is 
with respect to multiplication from the left or from the right. It is up to 
{\FORM} to decide what it considers to be most efficient when neither 
option is present. \vspace{4mm}

\noindent Note that one should not abbreviate this command to `multi', 
because there is a separate multi\index{multi} command (see 
\ref{substamulti}). \vspace{10mm}

%--#] multiply : 
%--#[ ndrop :

\section{ndrop}
\label{substandrop}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & ndrop; \\
       & ndrop {\tt<}list of expressions{\tt>};
\\ See also & drop (\ref{substadrop})
\end{tabular} \vspace{4mm}

In the first variety\index{ndrop} this statement cancels all 
drop\index{drop} plans. This means that all expressions scheduled for being 
dropped will be restored to their previous status of local or global 
expressions. In the second variety this happens only to the expressions 
that are specified. Example:
\begin{verbatim}
   Drop;
   Ndrop F1,F2;
\end{verbatim}
This drops all expressions, except for the expressions \verb:F1: and 
\verb:F2:. \vspace{10mm}

%--#] ndrop : 
%--#[ nfactorize :

\section{nfactorize}
\label{substanfactorize}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & nfactorize \verb:{:{\tt<}name of expression(s){\tt>}\verb:}:;
\\ See also & the chapter on polynomials~\ref{polynomials} and 
\ref{substafactorize}.
\end{tabular} \vspace{4mm}

\noindent When one uses a factorize (see \ref{substafactorize}) statement 
without arguments all expressions will be marked for factorization. If one 
would like to exclude a few expressions this can be done with the 
NFactorize statement. There should be at least one expression mentioned as 
in:
\begin{verbatim}
   Factorize;
   NFactorize expr12,expr29;
\end{verbatim}
One can also use the Factorize statement with a number of expressions after 
which the NFactorize statement can remove some from the list again as in:
\begin{verbatim}
   Factorize expr1,...,expr100;
   NFactorize expr12,expr29;
\end{verbatim}

\vspace{10mm}

%--#] nfactorize : 
%--#[ nfunctions :
 
\section{nfunctions}
\label{substanfunctions}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & n[functions] {\tt<}list of functions to be declared{\tt>}; \\
See also & functions (\ref{substafunctions}), cfunctions (\ref{substacfunctions})
\end{tabular} \vspace{4mm}

\noindent This statement\index{nfunction} declares 
noncommuting\index{noncommuting} functions. It is equal to the 
function\index{function} statement (see \ref{substafunctions}) which has 
the noncommuting property as its default. \vspace{10mm}

%--#] nfunctions : 
%--#[ nhide :

\section{nhide}
\label{substanhide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & nhide; \\
       & nhide {\tt<}list of expressions{\tt>};
\\ See also & hide (\ref{substahide}),
              unhide (\ref{substaunhide}),
              nunhide (\ref{substanunhide}),
              pushhide (\ref{substapushhide}),
              pophide (\ref{substapophide})
\end{tabular} \vspace{4mm}

\noindent In its first variety\index{nhide} this statement undoes all 
hide\index{hide} plans that exist thus far in the current module. In the 
second variety it does this only for the specified active\index{active} 
expressions. See the hide statement in \ref{substahide}. Example:
\begin{verbatim}
   Hide;
   Nhide F1,F2;
\end{verbatim}
Here all active expressions will be transferred to the hide file except for 
the expressions \verb:F1: and \verb:F2:. \vspace{10mm}

%--#] nhide : 
%--#[ normalize :

\section{normalize}
\label{substanormalize}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & normalize options \verb:{:{\tt<}name of function/set{\tt>}
         [{\tt<}argument specifications{\tt>}]\verb:}:;
\\ See also & argument (\ref{substaargument}), splitarg 
            (\ref{substasplitarg}), makeinteger (\ref{substamakeinteger})
\end{tabular} \vspace{4mm}

\noindent Normalizes\index{normalize} the indicated 
arguments\index{argument} of the indicated functions. Normalization means 
that the argument will be multiplied by the inverse of its 
coefficient\index{coefficient} 
(provided it is not zero). This holds for single term arguments. For 
multiple term arguments the inverse of the coefficient of the first term of 
the argument is used. The options and the argument specifications are as in 
the SplitArg\index{splitarg} statement (see \ref{substasplitarg}). Under normal 
circumstances the coefficient that is removed from the argument(s) is 
multiplied into the coefficient of the term. This can be avoid with the 
extra option
\verb:(0):. Hence

\leftvitem{4cm}{Normalize,f;}
\rightvitem{12cm}{changes {\tt f(2*x+3*y)} into {\tt 2*f(x+3/2*y)} but}

\leftvitem{4cm}{Normalize,(0),f;}
\rightvitem{12cm}{changes {\tt f(2*x+3*y)} into {\tt f(x+3/2*y)}.}

A more flexible way to extract the coefficient of the (first) term is by 
providing a scale factor as in

\leftvitem{4cm}{Normalize,$\wedge<n>$,f;}
\rightvitem{12cm}{The number n must be an integer (may be negative) and if 
the coefficient of the first term was c the whole term is multiplied by the 
factor $c^n$.}
\vspace{10mm}

%--#] normalize : 
%--#[ notinparallel :

\section{notinparallel}
\label{substanotinparallel}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & notinparallel; \\
       & notinparallel {\tt<}list of expressions{\tt>};
\\ See also & InParallel (\ref{substainparallel}), 
     ModuleOption (\ref{substamoduleoption})
\end{tabular} \vspace{4mm}

\noindent This statement is only active in the context of 
\TFORM\index{TFORM} and \ParFORM\index{ParFORM}. It vetoes (small) expressions to be executed side by 
side. For a complete explanation of this type of running one should look at 
the InParallel~\ref{substainparallel} statement. Because the default is 
that expressions are executed one by one, the major use of this statement 
is in constructions like:
\begin{verbatim}
   InParallel;
   NotInParallel F1,F25;
\end{verbatim}
which would first mark all expressions to be executed in simultaneous mode 
and then make an exception for {\tt F1} and {\tt F25}.
\vspace{10mm}

%--#] notinparallel : 
%--#[ nprint :

\section{nprint}
\label{substanprint}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & np[rint] {\tt<}list of names of expressions{\tt>};
\\ See also & print (\ref{substaprint})
\end{tabular} \vspace{4mm}

\noindent Statement\index{nprint} is used to take expressions from the list 
of expressions to be printed. When a print\index{print} statement is used 
(see \ref{substaprint}) without specification of expressions, all active 
expressions are marked for printing. With this statement one can remove a 
number of them from the list. \vspace{10mm}

%--#] nprint : 
%--#[ nskip :

\section{nskip}
\label{substanskip}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & nskip; \\
       & nskip {\tt<}list of expressions{\tt>};
\\ See also & skip (\ref{substaskip})
\end{tabular} \vspace{4mm}

\noindent In the first variety\index{nskip} it causes the cancellation of 
all skip\index{skip} plans (see \ref{substaskip}) for expressions. The 
status of these expressions is restored to their previous status (active 
local or global expressions). In the second variety this is done for the 
specified expressions only. Example:
\begin{verbatim}
   Skip;
   Nskip F1,F2;
\end{verbatim}
This causes all active expressions to be skipped except for the expressions 
\verb:F1: and \verb:F2:. \vspace{10mm}

%--#] nskip : 
%--#[ ntable :

\section{ntable}
\label{substantable}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & ntable {\tt<}options{\tt>} {\tt<}table to be 
declared{\tt>}; \\
See also & functions (\ref{substafunctions}), table (\ref{substatable}),
        ctable (\ref{substactable})
\end{tabular} \vspace{4mm}

\noindent This statement\index{ntable} declares a 
noncommuting\index{noncommuting} table\index{table!noncommuting}. For the 
rest it is identical to the table\index{table} command (see 
\ref{substatable}) which has the commuting property as its default. 
\vspace{10mm}

%--#] ntable : 
%--#[ ntensors :
 
\section{ntensors}
\label{substantensors}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & nt[ensors] {\tt<}list of tensors to be declared{\tt>}; \\
See also & functions (\ref{substafunctions}), tensors 
            (\ref{substatensors}), ctensors (\ref{substactensors})
\end{tabular} \vspace{4mm}

\noindent This statement\index{ntensor} declares 
noncommuting\index{noncommuting} tensors\index{tensor!noncommuting}. For 
the rest it is equal to the tensor\index{tensor} statement (see 
\ref{substatensors}) which has the commuting property as its default.

\noindent The options that exist for properties of tensors are the same as 
those for functions (see \ref{substafunctions}). \vspace{10mm}

%--#] ntensors : 
%--#[ nunfactorize :

\section{nunfactorize}
\label{substanunfactorize}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & nunfactorize \verb:{:{\tt<}name of expression(s){\tt>}\verb:}:;
\\ See also & the chapter on polynomials~\ref{polynomials} and 
\ref{substaunfactorize}.
\end{tabular} \vspace{4mm}

\noindent When one uses an UnFactorize (see \ref{substaunfactorize}) 
statement without arguments all expressions will be marked for being 
unfactorized. If one would like to exclude a few expressions this can be 
done with the NUnFactorize statement. There should be at least one expression 
mentioned as in:
\begin{verbatim}
   UnFactorize;
   NUnFactorize expr12,expr29;
\end{verbatim}
One can also use the UnFactorize statement with a number of expressions after 
which the NUnFactorize statement can remove some from the list again as in:
\begin{verbatim}
   UnFactorize expr1,...,expr100;
   NUnFactorize expr12,expr29;
\end{verbatim}

\vspace{10mm}

%--#] nunfactorize : 
%--#[ nunhide :

\section{nunhide}
\label{substanunhide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & nunhide; \\
       & nunhide {\tt<}list of expressions{\tt>};
\\ See also & hide (\ref{substahide}),
              nhide (\ref{substanhide}),
              unhide (\ref{substaunhide}),
              pushhide (\ref{substapushhide}),
              pophide (\ref{substapophide})
\end{tabular} \vspace{4mm}

\noindent In its first variety\index{nunhide} this statement undoes all 
unhide\index{unhide} (see \ref{substaunhide} and \ref{substahide}) plans 
that the system has in the current module. In its second variety this 
happens only with the specified expressions. Example:
\begin{verbatim}
   Unhide;
   Nunhide F1,F2;
\end{verbatim}
All expressions are taken from the hide\index{hide} system, except for the 
expressions \verb:F1: and \verb:F2:. \vspace{10mm}

%--#] nunhide : 
%--#[ nwrite :

\section{nwrite}
\label{substanwrite}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & nw[rite] {\tt<}keyword{\tt>};
\\ See also & on (\ref{substaon}), off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent This statement\index{nwrite} is considered 
obsolete\index{obsolete}. All its varieties have been taken over by the 
off\index{off} statement (see \ref{substaoff}) and the on\index{on} 
statement (see \ref{substaon}). The current version of {\FORM} will still 
recognize it, but the user is advised to avoid its usage. In future 
versions of {\FORM} it is scheduled to be used for a different kind of 
writing and hence its syntax may change considerably. The conversion 
program conv2to3\index{conv2to3} should help in the conversion of programs 
that have been written for version 2. For completeness we still give the 
syntax and how it should be converted.
The keywords are: \vspace{4mm}

\leftvitem{3.5cm}{stats\index{nwrite!stats}}
\rightvitem{13cm}{Same as: Off stats;}

\leftvitem{3.5cm}{statistics\index{nwrite!statistics}}
\rightvitem{13cm}{Same as: Off statistics;}

\leftvitem{3.5cm}{shortstats\index{nwrite!shortstats}}
\rightvitem{13cm}{Same as: Off shortstats;}

\leftvitem{3.5cm}{shortstatistics\index{nwrite!shortstatistics}}
\rightvitem{13cm}{Same as: Off shortstatistics;}

\leftvitem{3.5cm}{warnings\index{nwrite!warnings}}
\rightvitem{13cm}{Same as: Off warnings;}

\leftvitem{3.5cm}{allwarnings\index{nwrite!allwarnings}}
\rightvitem{13cm}{Same as: Off allwarnings;}

\leftvitem{3.5cm}{setup\index{nwrite!setup}}
\rightvitem{13cm}{Same as: Off setup;}

\leftvitem{3.5cm}{names\index{nwrite!names}}
\rightvitem{13cm}{Same as: Off names;}

\leftvitem{3.5cm}{allnames\index{nwrite!allnames}}
\rightvitem{13cm}{Same as: Off allnames;}

\leftvitem{3.5cm}{shortstats\index{nwrite!shortstats}}
\rightvitem{13cm}{Same as: Off shortstats;}

\leftvitem{3.5cm}{highfirst\index{nwrite!highfirst}}
\rightvitem{13cm}{Same as: Off highfirst;}

\leftvitem{3.5cm}{lowfirst\index{nwrite!lowfirst}}
\rightvitem{13cm}{Same as: Off lowfirst;}

\leftvitem{3.5cm}{powerfirst\index{nwrite!powerfirst}}
\rightvitem{13cm}{Same as: Off powerfirst;}
\vspace{10mm}

%--#] nwrite : 
%--#[ off :

\section{off}
\label{substaoff}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & off {\tt<}keyword{\tt>}; \\
       & off {\tt<}keyword{\tt>} {\tt<}option{\tt>};
\\ See also & on (\ref{substaon})
\end{tabular} \vspace{4mm}

\noindent Statement\index{off} to control settings\index{settings} during 
execution. Many of these settings replace older statements. The settings 
and their keywords are:
 
\leftvitem{3.5cm}{allnames\index{off!allnames}}
\rightvitem{13cm}{Turns the allnames mode off. The default.}
 
\leftvitem{3.5cm}{allwarnings\index{off!allwarnings}}
\rightvitem{13cm}{Turns off the printing of all warnings.}

\leftvitem{3.5cm}{backtrace\index{off!backtrace}}
\rightvitem{13cm}{Disables the printing of a stack trace on termination. This
is the default for normal form builds.}

\leftvitem{3.5cm}{checkpoint\index{off!checkpoint}}
\rightvitem{13cm}{Deactivates the checkpoint mechanism. See
\ref{checkpoints}.}

\leftvitem{3.5cm}{compress\index{off!compress}}
\rightvitem{13cm}{Turns compression mode off.}
 
\leftvitem{3.5cm}{finalstats\index{off!finalstats}}
\rightvitem{13cm}{Turns off the last line of statistics that is normally 
printed at the end of the run (introduced in version 3.2).}

\leftvitem{3.5cm}{flint\index{off!flint}}
\rightvitem{13cm}{Disables the interface to FLINT; use FORM's built-in
polynomial routines.}
 
\leftvitem{3.5cm}{highfirst\index{off!highfirst}}
\rightvitem{13cm}{Puts the sorting in a low first mode.}

\leftvitem{3.5cm}{insidefirst\index{off!insidefirst}}
\rightvitem{13cm}{Not active at the moment.}
 
\leftvitem{3.5cm}{lowfirst\index{off!lowfirst}}
\rightvitem{13cm}{Leaves the default low first mode and puts the sorting in 
a high first mode.}
 
\leftvitem{3.5cm}{names\index{off!names}}
\rightvitem{13cm}{Turns the names mode off. This is the default.}

\leftvitem{3.5cm}{nospacesinnumbers\index{off!nospacesinnumbers}}
\rightvitem{13cm}{\label{staoffnospacesinnumbers}\vspace{1ex}Allows very
long numbers to be printed with leading blank spaces at the beginning of a new
line. The numbers are usually broken up by placing a backslash character at
the end of the line and then continuing at the next line. For cosmetic
purposes \FORM\ puts usually a few blank spaces at the beginning of the line.
\FORM\ itself can read this but some programs cannot. This option can be turned
off by the `on nospacesinnumbers;' statement. The printing of the blank
characters can be restored by turning this variable off. See also page 
\ref{nospacesinnumbers} for a corresponding variable in the setup file.}
 
\leftvitem{3.5cm}{oldfactarg\index{off!oldfactarg}}
\rightvitem{13cm}{\label{staoffoldfactarg}Switches the use of the FactArg 
statement~\ref{substafactarg}\index{factarg} to the new mode of version 4 or 
later in which expressions in the argument of the mentioned function are 
completely factored over the rationals. The default is off.}
 
\leftvitem{3.5cm}{parallel\index{off!parallel}}
\rightvitem{13cm}{Disallows the running of the program in parallel mode 
(only relevant for parallel versions of \FORM).}
 
\leftvitem{3.5cm}{powerfirst\index{off!powerfirst}}
\rightvitem{13cm}{Puts the sorting back into `highfirst' mode.}

\leftvitem{3.5cm}{processstats\index{off!processstats}}
\rightvitem{13cm}{Turns the process by process printing of the statistics 
in \ParFORM{} off. Only the master process will be printing statistics. 
Other versions of \FORM{} will ignore this option.}

\leftvitem{3.5cm}{propercount\index{off!propercount}}
\rightvitem{13cm}{Turns the propercounting mode off. This means that for the 
generated terms in the statistics not only the `ground level' terms are 
counted but also terms that were generated inside function arguments.}
 
\leftvitem{3.5cm}{properorder\index{off!properorder}}
\rightvitem{13cm}{Turns the properorder mode off. This is the default.}
 
\leftvitem{3.5cm}{setup\index{off!setup}}
\rightvitem{13cm}{Switches off the mode in which the setup parameters are 
printed. This is the default.}

\leftvitem{3.5cm}{stats\index{off!stats}}
\rightvitem{13cm}{Same as `Off statistics'.}

\leftvitem{3.5cm}{statistics\index{off!statistics}}
\rightvitem{13cm}{Turns off the printing of statistics.}

\leftvitem{3.5cm}{shortstats\index{off!shortstats}}
\rightvitem{13cm}{Same as `Off shortstatistics'.}

\leftvitem{3.5cm}{shortstatistics\index{off!shortstatistics}}
\rightvitem{13cm}{Takes the writing of the statistics back from shorthand 
mode to the regular statistics mode in which each statistics messages takes 
three lines of text and one blank line.}

\leftvitem{3.5cm}{sortreallocate\index{off!sortreallocate}}
\rightvitem{13cm}{Turns off the reallocation of the small and large buffer
at the end of each module.}
 
\leftvitem{3.5cm}{threadloadbalancing\index{off!threadloadbalancing}}
\rightvitem{13cm}{\vspace{1.5ex}Disables the loadbalancing mechanism of 
\TFORM\ in parallel mode. In other versions of \FORM\ this option is 
ignored.}
 
\leftvitem{3.5cm}{threads\index{off!threads}}
\rightvitem{13cm}{Disallows multithreaded running in \TFORM\@.
In other versions of \FORM\ this option is ignored.}

\leftvitem{3.5cm}{threadstats\index{off!threadstats}}
\rightvitem{13cm}{Turns off the thread by thread printing of the statistics 
in \TFORM\@. Only the master thread will be printing statistics. Other 
versions of \FORM\ will ignore this option.}
 
\leftvitem{3.5cm}{totalsize\index{off!totalsize}}
\rightvitem{13cm}{Switches the totalsize mode off. For a more detailed 
description of the totalsize mode, see the "On TotalSize;" 
command~\ref{ontotalsize}.}

\leftvitem{3.5cm}{warnings\index{off!warnings}}
\rightvitem{13cm}{Turns off the printing of warnings.}

\leftvitem{3.5cm}{wtimestats\index{off!wtimestats}}
\rightvitem{13cm}{Disables the wall-clock time in the timing information in the 
statistics on the master.}

\noindent If a description is too short, one should also consult the 
description in the on statement (see \ref{substaon}). \vspace{10mm}

%--#] off : 
%--#[ on :
 
\section{on}
\label{substaon}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & on {\tt<}keyword{\tt>}; \\
       & on {\tt<}keyword{\tt>} {\tt<}option{\tt>};
\\ See also & off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent New statement to control settings during execution. Many of these 
settings replace older statements. The settings and their keywords are:
 
\leftvitem{3.5cm}{allnames\index{on!allnames}}
\rightvitem{13cm}{Same as `On names' but additionally all system variables 
are printed as well. Default is off. }
 
\leftvitem{3.5cm}{allwarnings\index{on!allwarnings}}
\rightvitem{13cm}{Puts the printing of warnings in a mode in which all 
warnings, even the very unimportant warnings are printed.}

\leftvitem{3.5cm}{backtrace\index{on!backtrace}}
\rightvitem{13cm}{Attempt to print a stack trace on termination, to assist with
debugging. This is off by default for normal form builds and on by default for
the debug binaries (vorm, tvorm, parvorm). For best results eu-addr2line or
addr2line should be installed on the system.}

\leftvitem{3.5cm}{checkpoint\index{on!checkpoint}}
\rightvitem{13cm}{Activates the checkpoint mechanism that allows for
the recovery of a crashed \FORM\ session. See \ref{checkpoints} for
detailed information.}

\leftvitem{3.5cm}{compress\index{on!compress}}
\rightvitem{13cm}{Turns compression mode on. This compression is a 
relatively simple compression that hardly costs extra computer time but 
saves roughly a factor two in disk storage. The old statement was `compress 
on' but this should be avoided in the future. This setting is the default if
\FORM\ has not been compiled with gzip or zstd support.}

\leftvitem{3.5cm}{compress,gzip\index{gzip}}
\rightvitem{13cm}{This setting is the default, if \FORM\ has been compiled
with gzip support but not with zstd support.
This option may be followed by a comma or a space and 
a single digit. It activates the gzip compression for the sort file. This 
compression can make the intermediate sort file considerably shorter at the 
cost of some CPU time.
The digit indicates the compression level. Zero means no 
compression and 9 is the highest level. The default level is 6. Above that 
the compression becomes very slow and doesn't gain very much extra.}

\leftvitem{3.5cm}{compress,zstd\index{zstd}}
\rightvitem{13cm}{This setting is the default, if \FORM\ has been compiled with
zstd support.
This option may be followed by a comma or a space and 
a single digit. It activates the zstd compression for the sort file. This 
compression performs better than gzip, both in terms of compression/
decompression rates and compression ratio.
The digit indicates the compression level. Zero means no 
compression and 9 is the highest level. The default level is 6. Above that 
the compression becomes very slow and doesn't gain very much extra.}

\leftvitem{3.5cm}{fewerstatistics\index{on!fewerstatistics}}
\rightvitem{13cm}{Determines how many of the statistics \FORM\ prints when a 
small buffer is full. The keyword can be followed by a positive integer in 
which case one out of that many of these statistics will be printed. If no 
number is given the default value of 10 is used. When the number that 
follows is zero, statistics are never printed when sorting the small buffer.}

\leftvitem{3.5cm}{fewerstats\index{on!fewerstats}}
\rightvitem{13cm}{Same as the above fewerstatistics.}

\leftvitem{3.5cm}{finalstats\index{on!finalstats}}
\rightvitem{13cm}{Determines whether \FORM\ prints a final line of run time 
statistics at the end of the run. Default is on.}

\leftvitem{3.5cm}{flint\index{on!flint}}
\rightvitem{13cm}{Enables the interface to FLINT for polynomial operations.
This is the default if \FORM\ has been compiled with FLINT support.
Currently this supports
PolyRatFun\index{polyratfun} (\ref{substapolyratfun}),
FactArg\index{factarg} (\ref{substafactarg}),
FactDollar\index{factdollar}\index{prefactdollar} (\ref{prefactdollar},
\ref{substafactdollar}),
div\_\index{div\_}\index{function!div\_} (\ref{fundiv}),
rem\_\index{rem\_}\index{function!rem\_} (\ref{funrem}),
mul\_\index{mul\_}\index{function!mul\_} (\ref{funmul}),
gcd\_\index{gcd\_}\index{function!gcd\_} (\ref{fungcd}),
and inverse\_\index{inverse\_}\index{function!inverse\_} (\ref{funinverse}).
\FORM\ still uses its built-in routines for Factorize\index{factorize}
(\ref{substafactorize})
and when using Modulus\index{modulus} (\ref{substamodulus}) mode.
Note that occasionally the overall sign of gcd\_ may differ from that of the
built-in routine.}
 
\leftvitem{3.5cm}{highfirst\index{on!highfirst}}
\rightvitem{13cm}{In this mode polynomials are sorted in a way that high 
powers come before low powers.}

%\leftvitem{3.5cm}{indentspace\index{on!indentspace}}
%\rightvitem{13cm}{Not active at the moment.}

\leftvitem{3.5cm}{insidefirst\index{on!insidefirst}}
\rightvitem{13cm}{Not active at the moment.}
 
\leftvitem{3.5cm}{lowfirst\index{on!lowfirst}}
\rightvitem{13cm}{In this mode polynomials are sorted in a way that low 
powers come before high powers. This is the default.}
 
\leftvitem{3.5cm}{names\index{on!names}}
\rightvitem{13cm}{Turns on the mode in which at the end of each module the 
names of all variables that have been defined by the user are printed. This 
is an inspection mode for debugging by the user. Default is off.}

\leftvitem{3.5cm}{nospacesinnumbers\index{on!nospacesinnumbers}}
\rightvitem{13cm}{\label{staonnospacesinnumbers}\vspace{1ex}Makes that very
long numbers are printed with no leading blank spaces at the beginning of a
new line. The numbers are usually broken up by placing a backspace character
at the end of the line and then continuing at the next line. For cosmetic
purposes \FORM\ puts usually a few blank spaces at the beginning of the line.
\FORM\ itself can read this but some programs cannot. Hence this printing of the
blank characters can be omitted by turning this variable on. See also page
\ref{nospacesinnumbers} for a corresponding variable in the setup file.}
 
\leftvitem{3.5cm}{oldfactarg\index{on!oldfactarg}}
\rightvitem{13cm}{\label{staonoldfactarg}Switches the use of the FactArg 
statement~\ref{substafactarg}\index{factarg} to the old mode from before 
version 4. This is a compatibility mode to allow oldprograms that rely on a 
specific working of the FactArg statement to still run. The default is 
off.}
 
\leftvitem{3.5cm}{parallel\index{on!parallel}}
\rightvitem{13cm}{Allows the running of the program in parallel mode unless 
other problems prevent this. This is of course only relevant for parallel 
versions of \FORM\@. The default is on.}
 
\leftvitem{3.5cm}{powerfirst\index{on!powerfirst}}
\rightvitem{13cm}{In this mode polynomials are sorted in a way that high 
powers come before low powers. The most relevant is however the combined 
power of all symbols.}

\leftvitem{3.5cm}{processstats\index{on!processstats}}
\rightvitem{13cm}{Only active for \ParFORM{}. It determines whether all
processes print their run time statistics or only the master process does so.
Default is on.}

\leftvitem{3.5cm}{propercount\index{on!propercount}}
\rightvitem{13cm}{Sets the counting of the terms during generation into 
`propercount' mode. This means that only terms at the `ground level' are 
counted and terms inside functions arguments are not counted in the 
statistics. This setting is the default.}
 
\leftvitem{3.5cm}{properorder\index{on!properorder}}
\rightvitem{13cm}{Turns the properorder mode on. The default is off. In the 
properorder mode \FORM\ pays particular attention to function arguments when 
bringing terms and expressions to normal form. This may cost a considerable 
amount of extra time. In normal mode \FORM\ is a bit sloppy (and much 
faster) about this, resulting sometimes in an ordering that appears without 
logic. This concerns only function arguments! This mode is mainly intended 
for the few moments in which the proper ordering is important.}
 
\leftvitem{3.5cm}{setup\index{on!setup}}
\rightvitem{13cm}{Causes the printing of the current setup parameters for 
inspection. Default is off.}

\leftvitem{3.5cm}{shortstatistics\index{on!shortstatistics}}
\rightvitem{13cm}{Puts the writing of the statistics in a shorthand mode in 
which the complete statistics are written on a single line only.}
 
\leftvitem{3.5cm}{shortstats\index{on!shortstats}}
\rightvitem{13cm}{Same as `On shortstatistics'.}

\leftvitem{3.5cm}{sortreallocate\index{on!sortreallocate}}
\rightvitem{13cm}{Reallocate the small and large buffer (also on the worker
threads) at the end of every module. In some cases this can significantly reduce
\FORM's memory usage as measured by ``resident set size''. For programs which
consist of a large number of very quickly-running modules, this can incur a
noticable performance penalty. See also \#sortreallocate (\ref{presortreallocate})
for a single-module version of this feature.}

\leftvitem{3.5cm}{statistics\index{on!statistics}}
\rightvitem{13cm}{Turns the writing of runtime statistics on. This is the 
default. It is possible to change this default with one of the setup 
parameters in the setup file (see \ref{setup}).}
 
\leftvitem{3.5cm}{stats\index{on!stats}}
\rightvitem{13cm}{Same as `On statistics'.}
 
\leftvitem{3.5cm}{threadloadbalancing\index{on!threadloadbalancing}}
\rightvitem{13cm}{\vspace{1.5ex}Causes the load balancing mechanism in \TFORM{}
to be turned on or off. Default is on. Ignored by other versions of \FORM.}
 
\leftvitem{3.5cm}{threads\index{on!threads}}
\rightvitem{13cm}{Allows the running of the program in multithreaded mode 
unless other problems prevent this. This is of course only relevant for 
\TFORM\@. Other versions of \FORM\ ignore this. The default is on.}
 
\leftvitem{3.5cm}{threadstats\index{on!threadstats}}
\rightvitem{13cm}{Only active for \TFORM\@. It determines whether all threads 
print their run time statistics or only the master thread does so. Default 
is on.}
 
\leftvitem{3.5cm}{totalsize\index{on!totalsize}}
\rightvitem{13cm}{\label{ontotalsize} Puts \FORM\ in a 
mode\index{totalsize} in which it tries to determine 
the maximum space occupied by all expressions at any given moment during 
the execution of the program. This space is the sum of the 
input/output/hide scratch files, the sort file(s) and the .str file. This 
maximum is printed at the end of the program. The same can be obtained with 
the "TotalSize ON" command in the setup (see \ref{setup}) or the -T option 
in the command tail when \FORM\ is started (see \ref{running}).}
 
\leftvitem{3.5cm}{warnings\index{on!warnings}}
\rightvitem{13cm}{Turns on the printing of warnings in regular mode. This 
is the default.}

\leftvitem{3.5cm}{wtimestats\index{on!wtimestats}}
\rightvitem{13cm}{Prints the wall-clock time in the timing information in the 
statistics. The wall-clock time is indicated by `\texttt{WTime}' instead of 
`\texttt{Time}' in the normal statistics with `\texttt{shortstatistics}' turned 
off. For parallel versions, it affects the statistics only on the master, and 
does not change those on the workers. The same can be obtained with the 
\texttt{-W} option in the command line options of \FORM{} (see \ref{running}) 
or `\texttt{WTimeStats ON}' in the setup (see \ref{setup}). Default is off.}

\vspace{10mm}

%--#] on : 
%--#[ once :
 
\section{once}
\label{substaonce}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & once {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement\index{once} is identical to the once option of the 
id\index{id} statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   once ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id once ....
\end{verbatim}
\vspace{10mm}

%--#] once : 
%--#[ only :
 
\section{only}
\label{substaonly}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & only {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement\index{only} is identical to the only option of the 
id\index{id} statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   only ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id only ....
\end{verbatim}
\vspace{10mm}

%--#] only : 
%--#[ polyfun :

\section{polyfun}
\label{substapolyfun}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & polyfun {\tt<}name of function{\tt>}; \\
       & polyfun;
\\ See also & moduleoption (\ref{substamoduleoption})
\end{tabular}\vspace{4mm}

\noindent Declares the specified\index{polyfun} function to be the 
`polyfun'. The polyfun is a function of which the single 
argument\index{argument} is considered to be the 
coefficient\index{coefficient} of the term. If two terms are otherwise 
identical the arguments of their polyfun will be added during the sorting, 
even if these arguments are little expressions. Hence
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_PolyFun_1)
\begin{verbatim}
    PolyFun acc;
    Local F = 3*x^2*acc(1+y+y^2)+2*x^2*acc(1-y+y^2);
\end{verbatim}
will result in
\begin{verbatim}
    F = x^2*acc(5+y+5*y^2);
\end{verbatim}
Note that the external numerical coefficient\index{coefficient} is also 
pulled inside the polyfun.

\noindent If the polyfun statement has no argument, \FORM\ reverts to its 
default mode in which no polyfun exists. This does not change any terms. If 
one would like to remove the polyfun from the terms one has to do that 
`manually' as in
\begin{verbatim}
    PolyFun;
    id  acc(x?) = x;
\end{verbatim}
in which we assume that previously the function acc had been declared to be 
the `polyfun'. \vspace{10mm}

%--#] polyfun : 
%--#[ polyratfun :

\section{polyratfun}
\label{substapolyratfun}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & polyratfun {\tt<}name of function{\tt>}; \\
       & polyratfun {\tt<}name of function{\tt>},{\tt<}name of function{\tt>}; \\
       & polyratfun;
\\ See also & polyfun (\ref{substapolyfun}),
			  moduleoption (\ref{substamoduleoption})
\end{tabular}\vspace{4mm}

\noindent Declares the specified\index{polyratfun} function to be the 
`polyratfun'. The polyratfun is a function with two 
arguments\index{argument} which together form a rational polynomial that 
acts as the 
coefficient\index{coefficient} of the term. If two terms are otherwise 
identical the arguments of their polyratfun will be added during the sorting, 
even if these arguments are little nontrivial. Hence
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_PolyRatFun_1)
\begin{verbatim}
    PolyRatFun acc;
    Local F = 3*x^2*acc(1+y+y^2,1-y)+2*x^2*acc(1-y+y^2,1+y);
\end{verbatim}
will result in
\begin{verbatim}
    F = x^2*acc(-y^3-10*y^2-2*y-5,y^2-1);
\end{verbatim}
Note that the external numerical coefficient\index{coefficient} is also 
pulled inside the polyratfun.

\noindent If the polyratfun statement has no argument, \FORM\ reverts to its 
default mode in which no polyratfun exists. This does not change any terms.

\noindent The polyratfun has many similarities with the polyfun (see 
\ref{substapolyfun}). At any moment there can only be at most either one 
polyfun or one polyratfun. Occurrences of the polyfun or the polyratfun 
with the wrong number or the wrong type of arguments are treated as regular 
functions.

\noindent There is a fundamental difference between the polyfun and the 
polyratfun. The last one is far more restrictive. It can have only numbers 
and symbols for its arguments. Also the ordering of the terms in the 
arguments can be different. In the polyratfun the terms are always sorted 
with the highest power first. In the polyfun the ordering is as with the 
regular terms. By default the lowest powers come first as one usually likes 
for power series expansions.

\noindent When two functions are specified, the first will be the 
PolyRatFun, and the second will be its inverse as in
\begin{verbatim}
    PolyRatFun rat,RAT;
\end{verbatim}
in which case
\begin{verbatim}
        RAT(x1,x2) = rat(x2,x1)
\end{verbatim}
This can be handy when one needs to solve systems of equations by manual 
interference. In that case exchanging numerators and denominators can be 
rather messy, while just changing a name is far less error-prone.

\noindent In many cases it may be very wasteful to keep full track of the 
complete rational polynomial. An example is the reduction of a complicated 
4-loop massless propagator diagram for which the rational polynomials can 
easily have hundreds of powers of the dimension parameter $D=4-2\epsilon$. 
In the end one has to expand in terms of $\epsilon$ although it is not 
known in advance to how many powers. For this there are two extra options 
in the polyratfun statement. The first is
\begin{verbatim}
    PolyRatFun rat(divergence,x);
\end{verbatim}
in which x is the name of the symbol of interest. In this case the 
polyratfun keeps only its most divergent term in this variable x and gives 
it the coefficient one. The result is that terms will never cancel and at 
the end of the calculation one can see how many poles in x were maximally 
present, and hence how far one has to expand in x. Because the contents of 
the polyratfun are extremely simple, the expensive rational arithmetic is 
completely absent and things should go rather fast.

\noindent In the second option one can specify how far one should expand:
\begin{verbatim}
    PolyRatFun rat(expand,x,power);
\end{verbatim}
In this case the denominator can only be a polynomial in the variable x. It 
will be expanded and multiplied by the numerator and eventually all terms 
with powers of x that are greater than 'power' will be discarded. The 
remaining incidence of the function rat will then have only one argument, 
like the polyfun (see \ref{substapolyfun}). The advantage is that now the 
addition of two coefficients is a simple and straightforward operation that 
does not need the expensive polynomial GCD computations.

\noindent Of course one can program such expansions externally and maybe 
better suited for the problem at hand, but using this option of the 
polyratfun is much faster and gives fewer chances of mistakes.

\vspace{10mm}

%--#] polyratfun : 
%--#[ pophide :

\section{pophide}
\label{substapophide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & pophide;
\\ See also & hide (\ref{substahide}),
              nhide (\ref{substanhide}),
              unhide (\ref{substaunhide}),
              nunhide (\ref{substanunhide}),
              pushhide (\ref{substapushhide})
\end{tabular} \vspace{4mm}

\noindent Undoes\index{pophide} the action of the most recent 
pushhide\index{pushhide} statement (see \ref{substapushhide}). If there is 
no matching pushhide statement an error will result. \vspace{10mm}

%--#] pophide : 
%--#[ print :
 
\section{print}
\label{substaprint}

\noindent \begin{tabular}{ll}
Type & Print statement\\
Syntax & Print [{\tt<}options{\tt>}]; \\
       & Print \verb:{:[{\tt<}options{\tt>}] {\tt<}expression{\tt>}\verb:}:; \\
       & Print [{\tt<}options{\tt>}] "{\tt<}format string{\tt>}" [{\tt<}objects{\tt>}];
\\ See also & print[\,] (\ref{substaprintc}),
              nprint (\ref{substanprint}),
              printtable (\ref{substaprinttable})
\end{tabular}\vspace{4mm}

\noindent General purpose print\index{print} statement. It has three modes. In 
the first two modes flags are set for the printing of expressions after the 
current module has been finished. The third mode concerns printing during 
execution. This allows the printing of individual terms or 
\$-variables\index{\$-variable} on a term by term basis. It should be 
considered as a useful debugging\index{debugging} device.

\noindent In the first mode all active\index{active} expressions are 
scheduled for printing. The options are\vspace{2mm}

\leftvitem{2cm}{{\tt<}filename{\tt>}}
\rightvitem{14cm}{The results will be printed to the file. The {\tt<} and 
{\tt>} are mandatory for this option.} This option can only be used in the 
version that prints out individual terms, i.e.\ the version with the format 
string.

\leftvitem{1cm}{+f}
\rightvitem{15cm}{Printing will be only to the log\index{log} 
file\index{file!log}.}

\leftvitem{1cm}{-f}
\rightvitem{15cm}{Printing will be both to the screen\index{screen} and to 
the log\index{log} file\index{file!log}. This is the default.}

\leftvitem{1cm}{+s}
\rightvitem{15cm}{Each term will start a new line. This is called the 
single\index{single term mode} term mode\index{mode!single term}.}

\leftvitem{1cm}{+ss}
\rightvitem{15cm}{Each term will start a new line. In addition each 
internal group will start a new line. A group is either a single function 
or all symbols together, or all dotproducts together, or all vectors 
together, or all Kronecker delta's together.}

\leftvitem{1cm}{+sss}
\rightvitem{15cm}{Like the +ss option but now each symbol and its power 
will start a new line. The same for individual dotproducts (and their 
power), vectors and Kronecker delta's.}

\leftvitem{1cm}{-s}
\rightvitem{15cm}{Regular term mode. There can be more terms in a line. 
Linebreaks\index{linebreaks} are placed when the line is full. The line 
size is set in the format\index{format} statement (see \ref{substaformat}). 
This is the default.}

\leftvitem{1cm}{-ss}
\rightvitem{15cm}{Lowers the single term mode to -s. If one would like to 
switch off the single term mode altogether, -s suffices.}

\leftvitem{1cm}{-sss}
\rightvitem{15cm}{Lowers the single term mode to -ss. If one would like to 
switch off the single term mode altogether, -s suffices.}

\noindent In the second mode one can specify
individual\index{individual expressions} expressions to be printed. The 
options hold for all the expressions that follow them until new options are 
specified. The options are the same as for the first mode.

\noindent In the third mode there is a format\index{format string} string 
as for the printf\index{printf} command in the C\index{C} programming 
language. Of course the control characters are not exactly the same as for 
the C language because the objects are different. The special characters 
are:

\leftvitem{1cm}{\%t\index{print!\%t}}
\rightvitem{15cm}{The current term will be printed at this position 
including its sign, even if this is a plus sign.}

\leftvitem{1cm}{\%T\index{print!\%T}}
\rightvitem{15cm}{The current term will be printed at this position. If its 
coefficient is positive no leading plus sign is printed.}

\leftvitem{1cm}{\%w\index{print!\%w}}
\rightvitem{15cm}{The number of the current thread will be printed. This is 
for \TFORM\ only. In the sequential version this combination is skipped. The 
number zero refers to the master thread.}
 
\leftvitem{1cm}{\%W\index{print!\%W}}
\rightvitem{15cm}{The number of the current thread and its CPU-time at the 
moment of printing. This is for \TFORM\ only. In the sequential version 
this combination is skipped. The number zero refers to the master thread.}

\leftvitem{1cm}{\%\$\index{print!\%\$}}
\rightvitem{15cm}{A dollar expression will be printed at this position. The 
name(s) of the dollar expression(s) should follow the format string in the 
order in which they are used in the format string.}

\leftvitem{1cm}{\%\%\index{print!\%\%}}
\rightvitem{15cm}{The character \%.}

\leftvitem{1cm}{\%}
\rightvitem{15cm}{If this is the last character of the string no linefeed 
will be printed at the end of the print command.}

\leftvitem{1cm}{$\backslash$n}
\rightvitem{15cm}{A linefeed\index{linefeed}.}

\noindent Each call is terminated with a linefeed\index{linefeed}. Example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Print_1)
\begin{verbatim}
    Symbols a,b,c;
    Local F = 3*a+2*b;
    Print "> %T";
    id  a = b+c;
    Print ">> %t";
    Print;
    .end
> 3*a
>>  + 3*b
>>  + 3*c
> 2*b
>>  + 2*b

   F =
      5*b + 3*c;
\end{verbatim}

\noindent In the third mode one can also use the +/--\,f options of the 
first mode. This should be placed before the format string as in
\begin{verbatim}
    Print +f "(%$) %t",$var;
\end{verbatim}

\noindent Because of the mixed nature of this statement it can occur in 
more than one location in the module. \vspace{10mm}

%--#] print : 
%--#[ print[] :

\section{\texorpdfstring{print[\,]}{print[ ]}}
\label{substaprintc}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & print[\,] \verb:{:[{\tt<}options{\tt>}] {\tt<}name{\tt>}\verb:}:;
\\ See also & print (\ref{substaprint})
\end{tabular}\vspace{4mm}

\noindent Print\index{print} statement\index{print[]} to cause the printing 
of expressions at the end of the current module. Is like the first two 
modes of the regular print statement (see \ref{substaprint}), but when 
printing \FORM\ does not print the contents of each bracket\index{bracket}, 
only the number of terms inside the bracket. Is to be used in combination 
with a bracket or an antibracket\index{antibracket} statement (see 
\ref{substabracket} and \ref{substaabrackets}). Apart from this the options 
are identical to those of the first two modes of the print statement. 
\vspace{10mm}

%--#] print[] : 
%--#[ printtable :

\section{printtable}
\label{substaprinttable}

\noindent \begin{tabular}{ll}
Type & Print statement\\
Syntax & printtable [{\tt<}options{\tt>}] {\tt<}tablename{\tt>};  \\
       & printtable [{\tt<}options{\tt>}] {\tt<}tablename{\tt>} $>$ {\tt<}filename{\tt>}; \\
       & printtable [{\tt<}options{\tt>}] {\tt<}tablename{\tt>} $>\!\!>$ {\tt<}filename{\tt>};
\\ See also & print (\ref{substaprint}),
            table (\ref{substatable}),
            fill (\ref{substafill}),
            fillexpression (\ref{substafillexpression}), \\ &
            and the table\_ function (\ref{funtable})
\end{tabular}\vspace{4mm}

\noindent Almost\index{printtable} the opposite of a 
FillExpression\index{fillexpression} statement (see 
\ref{substafillexpression}). Prints\index{print} the contents of a 
table\index{table} according to the current format (see 
\ref{substaformat}). The output can go to standard output, the 
log\index{log} file\index{file!log} or a specified file. The elements of 
the table that have been defined and filled are written in the form of 
fill\index{fill} statements (see \ref{substafill}) in such a way that they 
can be read in a future program to fill the table with the current 
contents. This is especially useful when the fillexpression statement has 
been used to dynamically extend tables based on what \FORM\ has encountered 
during running. This way those elements will not have to be computed again 
in future programs. 

\noindent The options are

\leftvitem{1.3cm}{+f}
\rightvitem{14.7cm}{Output is to the logfile and not to the screen.}

\leftvitem{1.3cm}{-f}
\rightvitem{14.7cm}{Output is both to the logfile and to the screen. This is 
the default.}

\leftvitem{1.3cm}{+s}
\rightvitem{14.7cm}{Output will be in a mode in which each new term starts a 
new line.}

\leftvitem{1.3cm}{-s}
\rightvitem{14.7cm}{Output will be in the regular mode in which new terms 
continue to be written on the same line within the limits of the number of 
characters per line as set in the format statement. Default is 72 
characters per line. This can be changed with the format\index{format} 
statement (see \ref{substaformat}).}

\noindent If redirection to a file is specified output will be only to this 
file. The +f option will be ignored. There are two possibilities:

\leftvitem{2.8cm}{$>$ filename}
\rightvitem{13.2cm}{The old contents of the file with name `filename' will be 
overwritten\index{overwrite}.}

\leftvitem{2.8cm}{$>\!\!>$ filename}
\rightvitem{13.2cm}{The table will be appended\index{append} to the file 
with the name `filename'. This allows the writing of more than one table to 
a file.}
\vspace{10mm}

%--#] printtable : 
%--#[ processbucketsize :

\section{processbucketsize}
\label{substaprocessbucketsize}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & processbucketsize {\tt<}value{\tt>};
\\ See also & moduleoption (\ref{substamoduleoption}), setup 
(\ref{setupprocessbucketsize})
\end{tabular}\vspace{4mm}

\noindent Sets the number of terms\index{processbucketsize} in the buckets that are sent 
to the secondary processors in \ParFORM\index{ParFORM}, one of the 
parallel\index{parallel} versions of \FORM\ (see chapter \ref{parallel}). In 
all other versions this statement is ignored. See also the moduleoption 
(\ref{substamoduleoption}) statement and the corresponding parameter for 
the setup (\ref{setupprocessbucketsize}). \vspace{10mm}

%--#] processbucketsize : 
%--#[ propercount :

\section{propercount}
\label{substapropercount}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & propercount {\tt<}on/off{\tt>};
\\ See also & on (\ref{substaon}), off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent This statement\index{propercount} is obsolete\index{obsolete}. 
The user should try to use the propercount option of the on\index{on} (see 
\ref{substaon}) or the off\index{off} (see \ref{substaoff}) statements. 
\vspace{10mm}

%--#] propercount : 
%--#[ pushhide :

\section{pushhide}
\label{substapushhide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & pushhide;
\\ See also & hide (\ref{substahide}),
              nhide (\ref{substanhide}),
              unhide (\ref{substaunhide}),
              nunhide (\ref{substanunhide}),
              pophide (\ref{substapophide})
\end{tabular} \vspace{4mm}

\noindent Hides\index{hide} all currently\index{pushhide} active 
expressions (see \ref{substahide}). The pophide\index{pophide} statement 
(see \ref{substapophide}) can bring them back to active status again. 
\vspace{10mm}

%--#] pushhide : 
%--#[ putinside :

\section{putinside}
\label{substaputinside}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & putinside {\tt<}name of function{\tt>} [,$<$bracket information$>$];
\\ See also & AntiPutInside (\ref{substaantiputinside})
\end{tabular}\vspace{4mm}

\noindent This statement\index{putinside} puts the complete term inside a 
function argument. The function must be a regular function (hence no tensor 
or table which are special types of functions). If there is 
bracket\index{bracket} information, this information should adhere to the 
syntax of the bracket statement (\ref{substaantiputinside}) and only 
occurrences of the bracket variables will be put inside the function. The 
coefficient will also be put inside the function.
\vspace{10mm}

%--#] putinside : 
%--#[ ratio :
 
\section{ratio}
\label{substaratio}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & ratio {\tt<}symbol1{\tt>} {\tt<}symbol2{\tt>} {\tt<}symbol3{\tt>};
\end{tabular} \vspace{4mm}

\noindent This statement\index{ratio} can be used for limited but fast 
partial\index{partial fractioning} fractioning. In the statement
\begin{verbatim}
   ratio a,b,c;
\end{verbatim}
in which \verb:a:, \verb:b: and \verb:c: should be three symbols {\FORM} 
will assume that $c = b-a$ and then make the substitutions
\begin{eqnarray}
    \frac{1}{a^m}\frac{1}{b^n} & = & \sum_{i=0}^{m-1}\sign{i}
        \binom{n-1+i}{n-1}\frac{1}{a^{m-i}}\frac{1}{c^{n+i}}
        +\sum_{i=0}^{n-1}\sign{m}
        \binom{m-1+i}{m-1}\frac{1}{b^{n-i}}\frac{1}{c^{m+i}}
        \nonumber \\
    \frac{b^n}{a^m} & = & \sum_{i=0}^n\binom{n}{i}\frac{c^i}{a^{m-n+i}}
            \ \ \ \ \ \ \ \hfill m\ge n \nonumber \\
    \frac{b^n}{a^m} & = & \sum_{i=0}^{m-1}\binom{n}{i}\frac{c^{n-i}}{a^{m-i}}
        + \sum_{i=0}^{n-m}\binom{m-1+i}{m-1}
            c^ib^{n-m-i}
            \ \ \ \ \ \ \ \hfill m<n \nonumber
\end{eqnarray}
\setcounter{equation}{3}
Of course, such substitutions can be made also by the user in a more 
flexible way. This statement has however the advantage of the best speed.
\vspace{4mm}

\noindent Actually the ratio statement is a leftover from the 
Schoonschip\index{Schoonschip} 
inheritance. For most simple partial fractioning one could use
\begin{verbatim}
   repeat id 1/[x+a]/[x+b] = (1/[x+a]-1/[x+b])/[b-a];
   repeat id [x+a]/[x+b] = 1-[b-a]/[x+b];
   repeat id [x+b]/[x+a] = 1+[b-a]/[x+a];
\end{verbatim}
or similar constructions. This does not give the speed of the 
binomials\index{binomials}, but it does make the program more readable and 
it is much more flexible.
\vspace{10mm}

%--#] ratio : 
%--#[ rcyclesymmetrize :
 
\section{rcyclesymmetrize}
\label{substarcyclesymmetrize}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & rc[yclesymmetrize] \verb:{:{\tt<}name of function/tensor{\tt>}
         [{\tt<}argument specifications{\tt>}];\verb:}: \\
See also & symmetrize (\ref{substasymmetrize}), cyclesymmetrize 
(\ref{substacyclesymmetrize}), antisymmetrize (\ref{substaantisymmetrize})
\end{tabular} \vspace{4mm}

\noindent The argument\index{rcyclesymmetrize} specifications are explained 
in the section on the symmetrize\index{symmetrize} statement (see 
\ref{substasymmetrize}). \medskip

\noindent The action of this statement is to
reverse\index{reverse cycle symmetrize}-cycle-symmetrize
\index{symmetrize!reverse cycle} the (specified) arguments of the functions 
that are mentioned. This means that the arguments are brought to `natural 
order' in the notation of \FORM\ by trying cyclic and reverse cyclic 
permutations\index{permutations} of the arguments or groups of arguments. 
The `natural order' may depend on the order of declaration of the 
variables. \vspace{10mm}

%--#] rcyclesymmetrize : 
%--#[ redefine :

\section{redefine}
\label{substaredefine}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & r[edefine] {\tt<}preprocessor variable{\tt>} "{\tt<}string{\tt>}";
\\ See also & preprocessor variables in the chapter on the preprocessor 
    (\ref{preprocessor})
\end{tabular} \vspace{4mm}

\noindent This statement\index{redefine} can be used to change the contents 
of preprocessor\index{preprocessor variables} 
variables\index{variables!preprocessor}. The new contents can be used after 
the current module has finished execution and the preprocessor becomes 
active again for further translation and compilation\index{compilation}. 
This termwise adaptation of the value of a preprocessor variable can be 
very useful in setting up multi module loops until a certain condition is 
not met any longer. Example:
\begin{verbatim}
   #do i = 1,1
      statements;
      if ( condition ) redefine i "0";
      .sort
   #enddo
\end{verbatim}
As long as there is a term that fulfils the condition the loop\index{loop} 
will continue. This defines effectively a while loop\index{loop!while} (see 
\ref{substawhile}) over various modules. Note that the .sort\index{.sort} 
instruction is essential. Note also that a construction like
\begin{verbatim}
   if ( count(x,1) > 3 ) redefine i "`i'+1";
\end{verbatim}
is probably not going to do what the user intends. It is not going to count 
terms with more than three powers of x. The preprocessor will insert the 
compile time value of the preprocessor variable i. If this is 0, then each 
time a term has more than three powers of x, i will get the string value 
\verb:0+1:. If one would like to do such counting, one should use a 
dollar variable\index{\$-variable} (see \ref{dollars}). \vspace{10mm}

%--#] redefine : 
%--#[ removespectator :

\section{removespectator}
\label{substaremovespectator}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & removespectator {\tt<}spectator;{\tt>};
\end{tabular} \vspace{4mm}

\noindent See chapter\ref{spectators} on spectators.
\vspace{10mm}

%--#] removespectator : 
%--#[ renumber :

\section{renumber}
\label{substarenumber}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & renumber {\tt<}number{\tt>};
\\ See also & sum (\ref{substasum})
\end{tabular}\vspace{4mm}

\noindent Renumbers\index{renumber} the dummy\index{dummy} 
indices\index{indices!dummy}. Dummy indices are indices of the type 
\verb:N1_?:. Normally \FORM\ tries to renumber these indices to make the 
internal representation of a term `minimal'. It does not try exhaustively 
though. Especially interference with symmetric or antisymmetric functions 
is far from perfect. This is due to considerations of economy. With the 
renumber statement the user can force \FORM\ to do better. The allowable 
options are:

\leftvitem{1cm}{0}
\rightvitem{15cm}{All exchanges of one pair of dummy indices are tried 
until all pair exchanges yield no improvements. This is the default if no 
option is specified.}

\leftvitem{1cm}{1}
\rightvitem{15cm}{If there are N sets of dummy indices all N! 
permutations\index{permutations} are tried. This can be very costly when a 
large number of indices is involved. Use with care!}\vspace{10mm}

%--#] renumber : 
%--#[ repeat :

\section{repeat}
\label{substarepeat}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & repeat; \\
       & repeat {\tt<}executable statement{\tt>}
\\ See also & endrepeat (\ref{substaendrepeat}), while (\ref{substawhile})
\end{tabular} \vspace{4mm}

\noindent The repeat\index{repeat} statement starts a
repeat\index{repeat environment} environment. It is terminated with an 
endrepeat\index{endrepeat} statement (see \ref{substaendrepeat}). The 
repeat statement and its matching endrepeat statement should be inside the 
same module. \vspace{4mm}

\noindent The statements inside the repeat environment should all be 
executable statements (or print statements) and if any of the executable 
statements inside the environment has changed the current term, the action 
of the endrepeat statement will be to bring control back to the beginning 
of the environment. In that sense the repeat/endrepeat combination acts as
\begin{verbatim}
   do
      executable statements
   while any action due to any of the statements
\end{verbatim}
The second form of the statement is a shorthand\index{shorthand} notation:
\begin{verbatim}
   repeat;
      single statement;
   endrepeat;
\end{verbatim}
is equivalent to
\begin{verbatim}
   repeat single statement;
\end{verbatim}
Particular attention should be given to avoid infinite\index{infinite loop} 
loops\index{loop!infinite} as in
\begin{verbatim}
   repeat id a = a+1;
\end{verbatim}
A more complicated infinite loop is
\begin{verbatim}
   repeat;
      id  S(x1?)*R(x2?) = T(x1,x2,x2-x1);
      id  T(x1?,x2?,x3?pos_) = T(x1,x2-2,x3-1)*X(x2);
      id  T(x1?,x2?,x3?) = S(x1)*R(x2);
   endrepeat;
\end{verbatim}
If the current term is S(2)*R(2), the statements in the loop do not change 
it in the end. Yet the program goes into an infinite loop, because the 
first id statement will change the term (action) and the third statement 
will change it back. {\FORM} does not check that the term is the same 
again. Hence there is action inside the repeat environment and hence the 
statements will be executed again. This kind of hidden action is a major 
source of premature\index{premature} 
terminations\index{termination!premature} of {\FORM} programs. \vspace{4mm}

\noindent Repeat environments can be nested\index{nested} with all other 
environments (and of course also with other repeat/endrepeat combinations). 
\vspace{10mm}

%--#] repeat : 
%--#[ replaceloop :

\section{replaceloop}
\label{substareplaceloop}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & replaceloop {\tt<}parameters{\tt>};
\\ See also & the findloop option of the if statement (\ref{substaif})
\end{tabular}\vspace{4mm}

\noindent This statement\index{replaceloop} causes the substitution of 
index\index{index loop} loops\index{loop!index}. An index loop is a 
sequence of contracted indices in which the indices are arguments of 
various instances of the same function and each contracted\index{contracted 
indices} index\index{index!contracted} occurs once in one instance of the 
function and once in another instance of the function. Such a contraction 
defines a connection and if a number of such connections between 
occurrences of the function form a loop this structure is a candidate for 
replacement. Examples of such loops are:
\begin{verbatim}
    f(i1,i2,j1)*f(i2,i1,j2)
    f(i1,i2,j1)*f(i2,i3,j2)*f(i1,i3,j3)
    f(i1,k1,i2,j1)*f(k2,i2,i3,j2)*f(i1,k3,i3,j3)
\end{verbatim}
The first term has a loop of two functions or vertices\index{vertices} and 
the other two terms each define a loop of three vertices. The parameters 
are:

\leftvitem{4cm}{$<$name$>$}
\rightvitem{12cm}{The name of the function that defines the `vertices'. 
This must always be the first parameter.}

\leftvitem{4cm}{arguments=number}
\rightvitem{12cm}{Only occurrences of the vertex function with the 
specified number of arguments will be considered. The specification of this 
parameter is mandatory.}

\leftvitem{4cm}{loopsize=number}
\rightvitem{12cm}{Only a loop with this number of vertices will be 
considered.}

\leftvitem{4cm}{loopsize=all}
\rightvitem{12cm}{All loop\index{loopsize} sizes will be considered and the 
smallest loop is substituted.}

\leftvitem{4cm}{loopsize$<$number}
\rightvitem{12cm}{Only loops with fewer vertices than `number' will be 
considered and the smallest loop will be substituted.}

\leftvitem{4cm}{outfun=$<$name$>$}
\rightvitem{12cm}{Name of an output function in which the remaining 
arguments of all the vertex functions will be given. This parameter is 
mandatory.}

\leftvitem{4cm}{include-$<$name$>$}
\rightvitem{12cm}{Name of a summable index that must be one of the links in 
the loop. This parameter is optional.}

\noindent The loopsize\index{loopsize} parameter is mandatory. Hence one of 
its options must be specified. The order of the parameters is not 
important. The only important thing is that the name of the vertex function 
must be first. The names of the keywords may be abbreviated as in
\begin{verbatim}
    ReplaceLoop f,a=3,l=all,o=ff,i=i2;
\end{verbatim}
although this does not improve the readability of the program. Hence a more 
readable abbreviated version might be
\begin{verbatim}
    ReplaceLoop f,arg=3,loop=all,out=ff,inc=i2;
\end{verbatim}

\noindent The action of the statement is to remove the vertex functions 
that constitute the loop and replace them by the output function. This 
outfun will have the arguments of all the vertex functions minus the 
contracted indices that define the loop. The order of the arguments is the 
order in which they are encountered when following the loop. The order of 
the arguments in the outfun depends however on the order in which \FORM\ 
encounters the vertices. Hence the outfun will often be 
cyclesymmetric\index{symmetric!cycle}\index{cyclesymmetric} (see 
\ref{substafunctions} and \ref{substacyclesymmetrize}). If \FORM\ has to 
exchange indices to make a `proper loop' (i.e.\ giving relevance to the 
first index as if it is something incoming and the second index as if it is 
something outgoing) and if the vertex function is 
antisymmetric\index{antisymmetric}\index{symmetric!anti}, each exchange will 
result in a minus sign. Examples:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_ReplaceLoop_1)
% TODO: the term order has been changed.
\begin{verbatim}
    Functions f(antisymmetric),ff(cyclesymmetric);
    Indices i1,...,i8;
    Local F = f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*f(i4,i7,i8);
    ReplaceLoop f,arg=3,loop=3,out=ff;
\end{verbatim}
would result in
\begin{verbatim}
    -f(i4,i7,i8)*ff(i4,i5,i6)
\end{verbatim}
and
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_ReplaceLoop_2)
% TODO: the term order has been changed.
\begin{verbatim}
    Functions f(antisymmetric),ff(cyclesymmetric);
    Indices i1,...,i9;
    Local F = f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*f(i4,i7,i8)
            *f(i6,i7,i8);
    ReplaceLoop f,arg=3,loop=all,out=ff;
\end{verbatim}
would give
\begin{verbatim}
    -f(i1,i4,i2)*f(i5,i2,i3)*f(i3,i1,i6)*ff(i4,i6)
\end{verbatim}
because the smallest loop will be taken. A number of examples can be found 
in the package\index{package!color} `color'\index{color package} for group 
theory\index{group theory} invariants that is part of the \FORM\ 
distribution. 

\noindent A related object is the findloop\index{findloop} option of the 
if\index{if} statement (see \ref{substaif}). This option just probes 
whether a loop is present but makes no replacements.\vspace{10mm}

%--#] replaceloop : 
%--#[ save :

\section{save}
\label{substasave}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & sa[ve] {\tt<}filename{\tt>} [{\tt<}names of global expressions{\tt>}];
\\ See also & load (\ref{substaload})
\end{tabular}\vspace{4mm}

\noindent Saves\index{save} the contents of the store\index{store file} 
file\index{file!store} (all global expressions that were stored in 
.store\index{.store} 
instructions) to a file with the indicated name. If a list of expressions 
is provided only those expressions are saved and the others are ignored. 

\noindent Together with the load\index{load} statement (see 
\ref{substaload}) the save statement provides a mechanism to transfer data 
in internal notation from one program to another. It is the preferred method 
to keep results of a lengthy job for further analysis without the need for 
the long initial running time.

\noindent In order to avoid confusion .sav\label{ex:sav}\index{.sav} is the 
preferred extension\index{extension!.sav} of saved files.\vspace{10mm}

%--#] save : 
%--#[ select :

\section{select}
\label{substaselect}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & select {\tt<}list of sets{\tt>} {\tt<}pattern{\tt>} = {\tt<}expression{\tt>};
\\ See also & identify (\ref{substaidentify})
\end{tabular} \vspace{4mm}

\noindent This statement\index{select} is identical to the select option of 
the id\index{id} statement (see \ref{substaidentify}). Hence
\begin{verbatim}
   select ....
\end{verbatim}
is just a shorthand notation for
\begin{verbatim}
   id select ....
\end{verbatim}
\vspace{10mm}

%--#] select : 
%--#[ set :

\section{set}
\label{substaset}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & set {\tt<}set to be declared{\tt>}[(option)]:{\tt<}element{\tt>} [{\tt<}more elements{\tt>}];
\end{tabular} \vspace{4mm}

\noindent Declares a single set\index{set} and specifies its 
elements\index{elements}. Sets have a type of variables connected to them. 
There can be sets of symbols, sets of functions, sets of vectors, sets of 
indices and sets of numbers. For the purpose of sets tensors\index{tensor} 
and tables\index{table} count as functions.

\noindent There can also be mixed sets\index{set!mixed} of indices and 
numbers. When a number could be either a fixed index or just a number \FORM\ 
will keep the type of the set unfixed. This can change either when the next 
element is a symbolic index or a number that cannot be a fixed index (like 
a negative number). If the status does not get resolved the set can be used 
in the wildcarding of both symbols and indices. Normally sets of numbers 
can be used only in the wildcarding of symbols.

Currently the only option is the ordered 
set\index{set!ordered}\index{ordered set}, indicated by
\begin{verbatim}
    Set name(ordered):x4,x3,x1,x6,x2;
\end{verbatim}
which would be stored as x1,x2,x3,x4,x6 if that would be the order of 
declaration.

\vspace{10mm}

%--#] set : 
%--#[ setexitflag :

\section{setexitflag}
\label{substasetexitflag}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & setexitflag;
\\ See also & exit (\ref{substaexit})
\end{tabular} \vspace{4mm}

\noindent Causes\index{setexitflag} termination\index{termination} of the 
program after execution\index{execution} of the current module has 
finished. \vspace{10mm}

%--#] setexitflag : 
%--#[ shuffle :
%
\section{shuffle}
\label{substashuffle}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & shuffle,functionname; \\
       & shuffle,once,functionname;
\\ See also & stuffle (\ref{substastuffle}) \\
            & merge (\ref{substamerge})
\end{tabular} \vspace{4mm}

\noindent This statement is exactly the same as the merge\index{merge} 
statement. It takes two occurrences of the mentioned function and outputs 
terms, each with one function in which the two argument lists have been 
merged in all different ways, keeping the relative ordering of the two 
lists preserved. It is the opposite of the 
distrib\_\index{distrib\_}\index{function!distrib\_} function (see 
\ref{fundistrib}). Hence
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Shuffle_1)
\begin{verbatim}
   Local F = f(a,b)*f(c,d);
   shuffle,f;
\end{verbatim}
will result in
\begin{verbatim}
      +f(a,b,c,d)+f(a,c,b,d)+f(a,c,d,b)+f(c,a,b,d)+f(c,a,d,b)+f(c,d,a,b)
\end{verbatim}
One can also obtain the same result with the statements
\begin{verbatim}
   Multiply,ff;
   repeat id f(x1?,?a)*f(x2?,?b)*ff(?c) =
            +f(?a)*f(x2,?b)*ff(?c,x1)
            +f(x1,?a)*f(?b)*ff(?c,x2);
   id f(?a)*f(?b)*ff(?c) = f(?c,?a,?b);
\end{verbatim}
but the advantage of the shuffle statement is that is also does a certain 
amount of combinatorics when there are identical arguments. Unfortunately 
the combinatorics doesn't extend over groups of arguments that are 
identical as in
\begin{verbatim}
    CF  f;
    L   F = f(0,1,0,1,0,1)*f(0,1,0,1,0,1);
    Shuffle,f;
    .end

Time =       0.00 sec    Generated terms =        141
               F         Terms in output =         32
                         Bytes used      =        892
\end{verbatim}
It does get the combinatorics between two zeroes or two ones, but it cannot 
handle the groups. The explicit method above however doesn't do any 
combinatorics and generates 924 terms.

One of the applications of this statement is in the field of harmonic 
sums\index{harmonic sum}, 
harmonic polylogarithms\index{harmonic polylogarithm} and multiple zeta 
values\index{multiple zeta value}\index{MZV}. Its twin brother is the 
stuffle statement\index{stuffle} (see \ref{substastuffle}).

When the option once is mentioned, only one pair will be contracted this 
way. Without this option all occurrences of the function inside a term will 
be treated till there are only terms with a single occurrence of the 
function.
\vspace{10mm}
%
%--#] shuffle : 
%--#[ skip :

\section{skip}
\label{substaskip}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & skip; \\
       & skip {\tt<}list of expressions{\tt>};
\\ See also & nskip (\ref{substanskip})
\end{tabular} \vspace{4mm}

\noindent In the first\index{skip} variety this statement marks all 
active\index{active} expressions that are in existence at the moment this 
statement is compiled, to be skipped. In the second variety this is done 
only to the active expressions that are specified. If an expression is 
skipped in a given module, the statements in the module have no effect on 
it. Also it will not be sorted\index{sort} again at the end of the module. 
This means that any bracket\index{bracket} information (see 
\ref{substabracket}) in the expression remains the way it was. Consult also 
the nskip\index{nskip} statement in \ref{substanskip}. \vspace{4mm}

\noindent Skipped expressions can be used in the expressions in the r.h.s.\ 
of id\index{id} statements (see \ref{substaidentify}) or 
multiply\index{multiply} statements (see \ref{substamultiply}), etc. 
\vspace{10mm}

%--#] skip : 
%--#[ sort :

\section{sort}
\label{substasort}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & sort;
\\ See also & term (\ref{substaterm}), endterm (\ref{substaendterm})
\end{tabular} \vspace{4mm}

\noindent Statement\index{sort} to be used inside the term\index{term} 
environment\index{environment!term} (see \ref{substaterm} and 
\ref{substaendterm}). It forces a sort in the same way as a 
.sort\index{.sort} instruction forces a sort for entire expressions. 
\vspace{10mm}

%--#] sort : 
%--#[ splitarg :

\section{splitarg}
\label{substasplitarg}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & splitarg options \verb:{:{\tt<}name of function/set{\tt>}
             [{\tt<}argument specifications{\tt>}]\verb:}:;
\\ See also & splitfirstarg (\ref{substasplitfirstarg}),
             splitlastarg (\ref{substasplitlastarg}),
             factarg (\ref{substafactarg})
\end{tabular}\vspace{4mm}

\noindent Takes\index{splitarg} the indicated argument\index{argument} of a 
function and if such an argument is a subexpression that consists on more 
than one term, all terms become single arguments of the function as in
\begin{verbatim}
   f(a+b-5*c*d) --> f(a,b,-5*c*d)
\end{verbatim}
The way arguments are indicated is rather similar to the way this is done 
in the argument\index{argument statement} statement (see 
\ref{substaargument}). One can however indicate only a single group of 
functions in one statement. Additionally there are other options. All 
options are in the order that they should be specified:

\leftvitem{5cm}{(term)}
\rightvitem{11cm}{Only terms that are a numerical multiple of the given 
term are split off. The terms that are split off will trail the remainder.}

\leftvitem{5cm}{((term))}
\rightvitem{11cm}{Only terms that contain the given term will be split off. 
The terms that are split off will trail the remainder.}

\noindent The statement is terminated with a sequence of functions or 
sets\index{set} of functions. The splitting action will apply only to the 
specified functions or to members of the set(s). If no functions or sets of 
functions are specified all functions will be treated, including the built 
in functions.
 
\noindent The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified, all arguments will be treated. \vspace{10mm}

%--#] splitarg : 
%--#[ splitfirstarg :

\section{splitfirstarg}
\label{substasplitfirstarg}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & splitfirstarg \verb:{:{\tt<}name of function/set{\tt>}
         [{\tt<}argument specifications{\tt>}]\verb:}:;
\\ See also & splitarg (\ref{substasplitarg}),
             splitlastarg (\ref{substasplitlastarg})
\end{tabular}\vspace{4mm}

\noindent A little\index{splitfirstarg} bit like the 
SplitArg\index{splitarg} statement (see \ref{substasplitarg}). Splits the 
given argument(s) into its first term and a remainder. Then replaces the 
argument by the remainder\index{remainder}, followed by the first term.

\noindent The statement is terminated with a sequence of functions or sets 
of functions. The splitting action will apply only to the specified 
functions or to members of the set(s). If no functions or sets\index{set} 
of functions are specified all functions will be treated, including the 
built in functions.
 
\noindent The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified all arguments will be treated. \vspace{10mm}

%--#] splitfirstarg : 
%--#[ splitlastarg :

\section{splitlastarg}
\label{substasplitlastarg}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & splitlastarg \verb:{:{\tt<}name of function/set{\tt>}
         [{\tt<}argument specifications{\tt>}]\verb:}:;
\\ See also & splitarg (\ref{substasplitarg}),
             splitfirstarg (\ref{substasplitfirstarg})
\end{tabular}\vspace{4mm}

\noindent A little\index{splitlastarg} bit like the 
SplitArg\index{splitarg} statement (see \ref{substasplitarg}). Splits the 
given argument(s) into its last term and a remainder. Then replaces the 
argument by the remainder, followed by the last term.

\noindent The statement is terminated with a sequence of functions or sets 
of functions. The splitting action will apply only to the specified 
functions or to members of the set(s). If no functions or sets\index{set} 
of functions are specified all functions will be treated, including the 
built in functions.
 
\noindent The argument specifications consist of a list of numbers, 
indicating the arguments that should be treated. If no arguments are 
specified all arguments will be treated. \vspace{10mm}

%--#] splitlastarg : 
%--#[ stuffle :
%
\section{stuffle}
\label{substastuffle}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & stuffle,functionname+; \\
       & stuffle,functionname-; \\
       & stuffle,once,functionname+; \\
       & stuffle,once,functionname-; \\
\\ See also & shuffle (\ref{substashuffle})
\end{tabular} \vspace{4mm}

\noindent This statement 
takes two occurrences of the mentioned function and outputs 
terms, each with one function in which the two argument lists have been 
merged according to the rules for nested sums. The plus and minus signs 
refer to ones favorite definition for nested sums. In the case of the plus 
sign, the definition is
\begin{eqnarray}
    \sum_{i=1}^N \sum_{i=1}^N & = & \sum_{i=1}^N \sum_{j=1}^{i-1}
        + \sum_{j=1}^N \sum_{i=1}^{j-1}
        + \sum_{i=j=1}^N
\end{eqnarray}
\setcounter{equation}{4}
while in the case of the minus the definition is
\begin{eqnarray}
    \sum_{i=1}^N \sum_{i=1}^N & = & \sum_{i=1}^N \sum_{j=1}^{i}
        + \sum_{j=1}^N \sum_{i=1}^{j}
        - \sum_{i=j=1}^N
\end{eqnarray}
\setcounter{equation}{5}
It is assumed that we have harmonic sums\index{harmonic sum} (see the 
summer library in the \FORM\ distribution). For such sums we expect 
functions with lists of nonzero integer arguments. Example:
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Stuffle_1)
\begin{verbatim}
    CF  S,R;
    Symbols N,n;
    L   F = S(R(1,-3),N)*S(R(-5,1),N);
    id  S(R(?a),n?)*S(R(?b),n?) = S(?a)*S(?b)*R(n);
    Stuffle,S-;
    id  S(?a)*R(n?) = S(R(?a),n);
    Print +s;
    .end

Time =       0.00 sec    Generated terms =         12
               F         Terms in output =         12
                         Bytes used      =        462

   F =
       + S(R(-6,-4),N)
       - S(R(-6,-3,1),N)
       - S(R(-6,1,-3),N)
       - S(R(-5,1,-4),N)
       + S(R(-5,1,-3,1),N)
       + 2*S(R(-5,1,1,-3),N)
       - S(R(-5,2,-3),N)
       - S(R(1,-5,-4),N)
       + S(R(1,-5,-3,1),N)
       + S(R(1,-5,1,-3),N)
       + S(R(1,-3,-5,1),N)
       - S(R(1,8,1),N)
      ;
\end{verbatim}
The above program is equivalent to the basis procedure in the summer 
library. As with the shuffle\index{shuffle} statement (see 
\ref{substashuffle}) a certain amount of combinatorics has been built in.

When the option once is mentioned, only one pair will be contracted this 
way. Without this option all occurrences of the function inside a term will 
be treated till there are only terms with a single occurrence of the 
function.

The stuffle command takes also the effect of roots of 
unity~\ref{rootofunity}\index{root of unity} into account in the same way 
that the signs of alternating sums are taken into account. This means that 
the sum indices don't have to be integers, but could be multiples of a 
single symbol that has been declared to be a root of 
unity~\ref{substasymbols}.
\vspace{10mm}
%
%--#] stuffle : 
%--#[ sum :

\section{sum}
\label{substasum}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & sum {\tt<}list of indices{\tt>};
\\ See also & renumber (\ref{substarenumber})
\end{tabular}\vspace{4mm}

\noindent The given indices will be summed\index{sum} over. There are two 
varieties. In the first the index is followed by a sequence of nonnegative 
short integers. In that case the summation means that for each of the 
integers a new instance of the term is created in which the index is 
replaced by that integer. In the second variety the index is either the 
last object in the statement or followed by another index. In that case the 
index is replaced by an internal dummy\index{dummy} 
index\index{index!dummy} of the type \verb:N1_?: (or with another number 
instead of the 1). Such indices have the current
default\index{default dimension} dimension\index{dimension!default} and can 
be renamed at will by \FORM\ to bring terms into standard notation. For 
example:
\begin{verbatim}
   f(N2_?,N1_?)*g(N2_?,N1_?)
\end{verbatim}
will be changed into
\begin{verbatim}
   f(N1_?,N2_?)*g(N1_?,N2_?).
\end{verbatim}
The user can use these dummy indices in the left hand side of 
id\index{id} statements.
\vspace{10mm}

%--#] sum : 
%--#[ switch :
%
\section{switch}
\label{substaswitch}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & switch,\$-variable; \\
\\ See also & case (\ref{substacase}), break (\ref{substabreak}),
		 default(\ref{substadefault}), endswitch (\ref{substaendswitch}).
\end{tabular} \vspace{4mm}

\noindent The argument of the switch statement should be a dollar variable 
which evaluates into an integer that first inside a {\FORM} word.
On a 64-bit processor this would be an integer in the range $-2^{31}$ to 
$2^{31}-1$. The switch statement should be paired with an endswitch 
statement. Between the two there will be a number of cases, each marked by 
an integer. If the value of the dollar variable corresponds to the value of 
one of these cases, execution will continue with the first statement after 
the corresponding case statement. Example:
\begin{verbatim}
    id  f(x?$x) = f(x);
    switch $x;
      case -1;
        some statements
      break;
      case 3;
        more statements
      break;
      case 4;
      case 5;
        and a few more
      break;
      default;
        and the default action
      break;
    endswitch;
\end{verbatim}
In principle the action is the same as in any computer language that has a 
switch construction, including the fall-through between case 4 and case 5. 
Whether the selection of the cases goes by binary search in a sorted list 
or by jumptable is determined by the endswitch statement.


\vspace{10mm}
%
%--#] switch : 
%--#[ symbols :
 
\section{symbols}
\label{substasymbols}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & s[ymbols] {\tt<}list of symbols to be declared{\tt>};
\end{tabular}\vspace{4mm}

\noindent Declares one or more symbols\index{symbol}. Each symbol can be 
followed by a number of options. These are (assuming that x is the symbol 
to be declared):

\leftvitem{2.4cm}{x\hash{}r}
\rightvitem{13.8cm}{The symbol is real\index{real}. This is the default.}

\leftvitem{2.4cm}{x\hash{}c}
\rightvitem{13.8cm}{The symbol is complex\index{complex}. This means that two 
spaces are reserved for this symbol, one for x and one for x\hash{} (the 
complex conjugate).}

\leftvitem{2.4cm}{x\hash{}i}
\rightvitem{13.8cm}{The symbol is imaginary\index{imaginary}.}

\leftvitem{2.4cm}{x\hash{}=number}
\rightvitem{13.8cm}{The symbol is a number-th root of
unity\index{root of unity}\label{rootofunity} This means that the number-th 
power of the symbol will be replaced by one and half this power (if even) 
by -1. Negative powers will be replaced by corresponding positive powers.}

\leftvitem{2.4cm}{x(:5)}
\rightvitem{13.8cm}{The symbol has the maximum power 5. This means that $x^6$ 
and higher powers are automatically eliminated during the 
normalization\index{normalization} of a term. Of course any other number, 
positive or negative, is allowed.}

\leftvitem{2.4cm}{x(-3:)}
\rightvitem{13.8cm}{The symbol has the minimum power -3. This means that 
$x^{-4}$ and lower powers are automatically eliminated during the 
normalization of a term. Of course any other number, positive or negative, 
is allowed. Note that when the minimum power is positive, terms that have 
no power of x should technically be eliminated, but \FORM\ will not do so. 
Such an action can be achieved at any moment with a combination of the 
count\index{if!count}\index{count} option of an if\index{if} statement (see 
\ref{substaif}) and a discard\index{discard} statement (see 
\ref{substadiscard}).}

\leftvitem{2.4cm}{x(-3:5)}
\rightvitem{13.8cm}{The combination of a maximum and a minimum power 
restriction (see above).}\vspace{4mm}

\noindent Complexity properties and power restrictions can be combined. In 
that case the complexity properties come first and then the power 
restrictions.\vspace{10mm}

%--#] symbols : 
%--#[ symmetrize :

\section{symmetrize}
\label{substasymmetrize}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & symm[etrize] \verb:{:{\tt<}name of function/tensor{\tt>}
         [{\tt<}argument specifications{\tt>}];\verb:}: \\
See also & antisymmetrize (\ref{substaantisymmetrize}), cyclesymmetrize 
(\ref{substacyclesymmetrize}), rcyclesymmetrize (\ref{substarcyclesymmetrize})
\end{tabular} \vspace{4mm}

\noindent The arguments\index{symmetrize} consist of the name of a function 
(or a tensor), possibly followed by some specifications. Hence we have the 
following varieties: \vspace{1mm}

\leftvitem{5cm}{{\tt<}name{\tt>}}
\rightvitem{11cm}{The function is symmetrized in all its arguments.}

\leftvitem{5cm}{{\tt<}name{\tt><}numbers{\tt>}}
\rightvitem{11cm}{The function is symmetrized in the arguments that are 
mentioned. If there are fewer arguments than the highest number mentioned 
in the list or arguments, no symmetrization will take place.}

\leftvitem{5cm}{{\tt<}name{\tt>:<}number{\tt>}}
\rightvitem{11cm}{Only functions with the specified number of arguments 
will be considered. Note: the number should follow the colon directly 
without intermediate space or comma.}

\leftvitem{5cm}{{\tt<}name{\tt>:<}number{\tt><}numbers{\tt>}}
\rightvitem{11cm}{If there is a number immediately following the colon, 
only functions with exactly that number of arguments will be considered. If 
the list of arguments contains numbers greater than this number, they will 
be ignored. If no number follows the colon directly, this indicates that 
symmetrization will take place, no matter the number of arguments of the 
function. If the list of arguments has numbers greater than the number of 
arguments of the function, these numbers will be ignored.}

\leftvitem{5cm}{{\tt<}name{\tt>}

{\tt<}(groups of numbers){\tt>}}
\rightvitem{11cm}{The groups are specified as lists of numbers of arguments 
between parenthesis. All groups must have the same number of arguments or 
there will be a compile error. The groups are symmetrized as groups. The 
arguments do not have to be adjacent. Neither do they have to be ordered. 
The symmetrization\index{symmetrization} takes place in a way that the first elements of the 
groups are most significant, etc. If any argument number is greater than 
the number of arguments of the function, no symmetrization will take place.}

\leftvitem{5cm}{{\tt<}name{\tt>:<}number{\tt>}

{\tt<}(groups of numbers){\tt>}}
\rightvitem{11cm}{The groups are specified as lists of numbers of arguments 
between parenthesis. All groups must have the same number of arguments or 
there will be a compile error. The groups are symmetrized as groups. The 
arguments do not have to be adjacent. Neither do they have to be ordered. 
The symmetrization takes place in a way that the first elements of the 
groups are most significant, etc. If no number follows the colon directly 
symmetrization takes place no matter the number of arguments of the 
function. Groups that contain a number that is greater than the number of 
arguments of the function will be ignored. If a number follows the colon 
directly, only functions with that number of arguments will be symmetrized. 
Again, groups that contain a number that is greater than the number of 
arguments of the function will be ignored.}
\vspace{3mm}

\noindent The action of this statement is to symmetrize the 
(specified) arguments of the functions that are mentioned. This means that 
the arguments are brought to `natural order' in the notation of \FORM\ by 
trying permutations\index{permutation} of the arguments or groups of 
arguments. The `natural order' may depend on the order of declaration of 
the variables. \vspace{4mm}

\noindent Examples:
\begin{verbatim}
   Symmetrize Fun;
   Symmetrize Fun 1,2,4;
   Symmetrize Fun:5;
   Symmetrize Fun: 1,2,4;
   Symmetrize Fun:5 1,2,4;
   Symmetrize Fun (1,6),(7,3),(5,2);
   Symmetrize Fun:8 (1,6),(7,3),(5,2);
   Symmetrize Fun: (1,6),(7,3),(5,2);
\end{verbatim}
 \vspace{10mm}

%--#] symmetrize : 
%--#[ table :

\section{table}
\label{substatable}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & table {\tt<}options{\tt>} {\tt<}table to be 
declared{\tt>}; \\
See also & functions (\ref{substafunctions}), ctable (\ref{substactable}),
        ntable (\ref{substantable}), fill (\ref{substafill})
\end{tabular}\vspace{4mm}

\noindent The statement declares a single table\index{table}. A table is a 
very special instance of a function. Hence it can be either 
commuting\index{commuting} or noncommuting\index{noncommuting}. The table 
statement declares its function to be commuting. A noncommuting table is 
declared with the ntable\index{ntable} statement (see \ref{substantable}). 
A table has a number of table\index{table indices} indices (in the case of 
zero indices the table has to be sparse) and after that it can have a 
number of regular function arguments with or without wildcarding. The table 
indices can come in two varieties: matrix\index{matrix like} like or 
sparse\index{sparse}. In the case of a matrix like table\index{table!matrix 
like}, for each of the indices a range has to be specified. \FORM\ then 
reserves a location for each of the potential elements. For a sparse 
table\index{table!sparse} one only specifies the number of indices. Sparse 
tables take less space, but they require more time searching whether an 
element has been defined. For a matrix like table \FORM\ can look directly 
whether an element has been defined. Hence one has a tradeoff between space 
and speed. A zero-dimensional (sparse) table has of course only a single 
element.\vspace{4mm}

\noindent Table elements are defined with the fill\index{fill} statement (see 
\ref{substafill}). Fill statements for table elements cannot be used before 
the table has been declared with a table or ntable statement.\vspace{4mm}

\noindent When \FORM\ encounters an unsubstituted table it will look for its 
indices. Then it can check whether the table element has been defined. If 
not, it can either complain (when the `strict'\index{strict} option is 
used) or continue without substitution. Note that an unsubstituted table 
element is a rather expensive object as \FORM\ will frequently check whether 
it can be substituted (new elements can be defined in a variety of 
ways....). If the indices match a defined table element, \FORM\ will check 
whether the remaining arguments of the table will match the function-type 
arguments given in the table declaration in the same way regular function 
arguments are matched. Hence these arguments can contain 
wildcards\index{wildcards} and even argument\index{argument field} field 
wildcards. If a match occurs, the table is replaced immediately.

\noindent The options are

\lefttabitem{check\index{table!check}}
\tabitem{A check is executed on table boundaries. An element that is 
outside the table boundaries (regular matrix type tables only) will cause 
an error message and execution will be halted.}

\lefttabitem{relax\index{table!relax}}
\tabitem{Normally all elements of a table should be defined during 
execution and an undefined element will give an error message. The relax 
option switches this off and undefined elements will remain as if they are 
regular functions.}

\lefttabitem{sparse\index{table!sparse}}
\tabitem{The table is considered to be sparse. In the case of a sparse 
table only the number of indices should be specified. Ranges are not 
relevant. Each table element is stored separately. Searching for table 
elements is done via a balanced tree\index{tree!balanced}. This takes of 
course more time than the matrix type search with is just by indexing. A 
matrix like table\index{table!matrix like} is the default.}

\lefttabitem{strict\index{table!strict}}
\tabitem{If this option is specified all table elements that are 
encountered during execution should be defined. An undefined table element 
will result in an error and execution is halted. Additionally all table 
elements should be properly defined at the end of the module in which the 
table has been defined.}

\lefttabitem{zerofill\index{table!zerofill}}
\tabitem{Any undefined table element is considered to be 
zero.}

\lefttabitem{onefill\index{table!onefill}}
\tabitem{Any undefined table element is considered to be 
one.}\vspace{10mm}

\noindent The defaults are that the table is matrix like and table elements 
that cannot be substituted will result in an error.\vspace{4mm}

\noindent Ranges for indices in matrix like tables are indicated with a 
colon as in
\begin{verbatim}
   Symbol x;
   Table t1(1:3,-2:4);
   Table t2(0:3,0:3,x?);
   Table sparse,t3(4);
\end{verbatim}
The table \verb:t1: is two dimensional and has 21 elements. The table 
\verb:t2: is also two dimensional and has 16 elements. In addition there is 
an extra argument which can be anything that a wildcard symbol will match. 
The table \verb:t3: is a sparse table with 4 indices.\vspace{4mm}

\noindent If the computer on which \FORM\ runs is a 32\index{32 bits} bit 
computer no table can have more than $2^{15} = 32768$ elements. On a 
64\index{64 bits} bit computer the limit is $2^{31}$, but one should take 
into account that each element declared causes some overhead. \vspace{4mm}

\noindent If the wildcarding in the declaration of a table involves the 
definition of a dollar variable\index{\$-variable} (this is allowed! See 
\ref{dollars}) parallel execution of the entire remainder of the \FORM\ 
program is switched off. This is of course only relevant for parallel 
versions of \FORM\@. But if at all possible one should try to find better 
solutions than this use of dollar variables, allowing future parallel 
processing of the program.

\noindent In some cases tables are built up slowly during the execution of 
a program and used incrementally. This means that more and more CPU memory 
is needed. Eventually this can cause a crash by lack of memory. In the case 
that the earlier elements of the table aren't needed anymore, one could use 
the ClearTable~\ref{substacleartable} statement.
\vspace{10mm}

%--#] table : 
%--#[ tablebase :

\section{tablebase}
\label{substatablebase}

\noindent This statement is explained in the chapter on 
tablebases\index{tablebase} (\ref{tablebase}).
\vspace{10mm}

%--#] tablebase : 
%--#[ tensors :
 
\section{tensors}
\label{substatensors}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & t[ensors] {\tt<}list of tensors to be declared{\tt>}; \\
See also & functions (\ref{substafunctions}), ctensors 
        (\ref{substactensors}), ntensors (\ref{substantensors})
\end{tabular}\vspace{4mm}

\noindent A tensor\index{tensor} is a special function that can have only 
indices for its arguments. If an index a contracted with the index of a 
vector Schoonschip\index{Schoonschip} notation is used. This means that the 
vector is written as a pseudo argument of the tensor. It should always be 
realized that in that case in principle the actual argument is a dummy 
index. Tensors come in two varieties: commuting\index{commuting} and 
noncommuting\index{noncommuting}. The tensor statement declares a tensor to 
be commuting. In order to declare a tensor to be noncommuting one should 
use the ntensor\index{ntensor} statement (see \ref{substantensors}).

\noindent The options that exist for properties of tensors are the same as 
those for functions (see \ref{substafunctions}). \vspace{10mm}

%--#] tensors : 
%--#[ term :

\section{term}
\label{substaterm}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & term;
\\ See also & endterm (\ref{substaendterm}), sort (\ref{substasort})
\end{tabular} \vspace{4mm}

\noindent Begins the term\index{term} environment\index{environment!term}. 
This environment is terminated with the endterm\index{endterm} statement 
(see \ref{substaendterm}). The action is that temporarily the current term 
is seen as a little expression by itself. The statements inside the 
environment are applied to it and one can even sort the results with the 
sort\index{sort} statement (see \ref{substasort}) which should not be 
confused with the .sort\index{.sort} instruction that terminates a module. 
Inside the term environment one can have only executable statements and 
possibly term-wise print statements (see \ref{substaprint}). When the end 
of the term environment is reached, the results are sorted (as would be 
done with an expression at the end of a module) and execution continues 
with the resulting terms. This environment can be nested\index{nested}. 
\vspace{10mm}

%--#] term : 
%--#[ testuse :

\section{testuse}
\label{substatestuse}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & testuse ["{\tt<}tablename(s){\tt>}"];
\\ See also & tablebases (\ref{tablebase}), testuse (\ref{tbltestuse})
\end{tabular} \vspace{4mm}

\noindent This statement\index{testuse} is explained in the chapter on 
tablebases\index{tablebase}.\vspace{10mm}

%--#] testuse : 
%--#[ threadbucketsize :
 
\section{threadbucketsize}
\label{substathreadbucketsize}

\noindent \begin{tabular}{ll}
Type & Declaration\\
Syntax & ThreadBucketSize,number;
\\ See also & the section on \TFORM~(\ref{tform})
\end{tabular} \vspace{4mm}

\noindent This statement\index{threadbucketsize} is only active in 
\TFORM\index{TFORM}. In all other versions of \FORM\ it is ignored. It sets 
the size of the buckets\index{bucket} that the master\index{master} thread 
prepares for treatment by the workers. Bigger buckets means less overhead 
in signals, but when the buckets are too big the workers may have to wait 
too long before getting tasks. The best bucket size is usually between 100 
and 1000, although this depends very much on the problem. The default value 
is currently 500. For more ways to set this variable one should consult the 
section on \TFORM\ (\ref{tform}). To find out what its value is, use the
`ON,setup;' statement (\ref{substaon} and \ref{setup}). \vspace{10mm}

%--#] threadbucketsize : 
%--#[ topolynomial :

\section{topolynomial}
\label{substatopolynomial}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & topolynomial[,OnlyFunctions[,{\tt<}list of functions{\tt>}]];
\\ See also & factarg (\ref{substafactarg}), FromPolynomial 
(\ref{substafrompolynomial}), ArgToExtraSymbol (\ref{substaargtoextrasymbol}) 
\\& and ExtraSymbols (\ref{substaextrasymbols},
\ref{sect-extrasymbols}).
\end{tabular} \vspace{4mm}

\noindent Starting with version 4.0 of \FORM{} some built in operations or
statements can only deal with symbols and numbers. Examples of this are 
factorization~(\ref{substafactarg}) and output simplification (still to be 
implemented). The ToPolynomial statement takes each term, looks for objects 
that are not symbols to positive powers and replaces them by symbols. If 
the object has been encountered before, the same symbol will be used, 
otherwise a new symbol will be defined. The object represented by the 
`extra symbol' is stored internally and can be printed if needed with the 
\%X option in the \#write instruction (\ref{prewrite}). Note that negative 
powers of symbols will also be replaced.

In some cases one would like to do this only for a subset of objects. It is 
possible to do this only for functions, using the OnlyFunctions option. If 
no functions are specified, all functions will be replaced by extra 
symbols. If a list of functions is specified, only those functions will be 
replaced.
\vspace{10mm}

%--#] topolynomial : 
%--#[ tospectator :

\section{tospectator}
\label{substatospectator}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & tospectator {\tt<}spectator;{\tt>};
\end{tabular} \vspace{4mm}

\noindent See chapter\ref{spectators} on spectators.
\vspace{10mm}

%--#] tospectator : 
%--#[ totensor :

\section{totensor}
\label{substatotensor}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & totensor [nosquare] [functions] [!{\tt<}vector or set{\tt>}] {\tt<}vector{\tt>} {\tt<}tensor{\tt>}; \\
       & totensor [nosquare] [functions] [!{\tt<}vector or set{\tt>}] {\tt<}tensor{\tt>} {\tt<}vector{\tt>};
\\ See also & tovector (\ref{substatovector})
\end{tabular} \vspace{4mm}

\noindent Looks for multiple\index{totensor} occurrences of the given 
vector, either inside dotproducts, contracted with a tensor, as argument of 
a function or as a loose vector with an index. In all occurrences in 
which the vector has been contracted a dummy index is introduced to make 
the contraction apparent. Then all these vectors with their indices are 
replaced by the specified tensor with all the indices of these vectors. To 
make this clearer:
\begin{eqnarray}
    p^{\mu_1}p^{\mu_2}p^{\mu_3} \rightarrow t^{\mu_1\mu_2\mu_3} \nonumber
\end{eqnarray}
\setcounter{equation}{6}
and hence
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_ToTensor_1)
% TODO: the functions option needed?
\begin{verbatim}
   p.p1^2*f(p,p1)*p(mu)*tt(p1,p,p2,p)
\end{verbatim}
gives after \verb:totensor p,t;:
\begin{verbatim}
   f(N1_?,p1)*tt(p1,N2_?,p2,N3_?)*t(p1,p1,mu,N1_?,N2_?,N3_?)
\end{verbatim}\vspace{4mm}

\noindent The options are

\leftvitem{3.5cm}{nosquare\index{totensor!nosquare}}
\rightvitem{13cm}{Dotproducts with twice the specified vector (square of 
the vector) are not taken into account.}

\leftvitem{3.5cm}{functions\index{totensor!functions}}
\rightvitem{13cm}{Vectors that are arguments of regular functions will also 
be considered. By default this is not done.}

\leftvitem{3.5cm}{!vector\index{totensor!"!vector}}
\rightvitem{13cm}{Dotproducts involving the specified vector are not 
treated.}

\leftvitem{3.5cm}{!set\index{totensor!"!set}}
\rightvitem{13cm}{The set should be a set of vectors. All dotproducts 
involving a vector of the set are not treated.}\vspace{10mm}

%--#] totensor : 
%--#[ tovector :

\section{tovector}
\label{substatovector}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & tovector {\tt<}tensor{\tt>} {\tt<}vector{\tt>}; \\
       & tovector {\tt<}vector{\tt>} {\tt<}tensor{\tt>};
\\ See also & totensor (\ref{substatotensor})
\end{tabular} \vspace{4mm}

\noindent The opposite\index{tovector} of the totensor\index{totensor} 
statement. The tensor is replaced by a product of the given vectors, each 
with one of the indices of the tensor as in:
\begin{eqnarray}
    t^{\mu_1\mu_2\mu_3} \rightarrow p^{\mu_1}p^{\mu_2}p^{\mu_3} \nonumber
\end{eqnarray}\vspace{10mm}
\setcounter{equation}{7}

%--#] tovector : 
%--#[ trace4 :

\section{trace4}
\label{substatrace}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & trace4 [{\tt<}options{\tt>}] {\tt<}index{\tt>}; \\
See also & tracen (\ref{substatracen}), chisholm (\ref{substachisholm}),
    unittrace (\ref{substaunittrace}) \\ &
    and the chapter on gamma algebra (\ref{gammaalgebra})
\end{tabular} \vspace{4mm}

\noindent Takes the trace\index{trace4} of the gamma\index{gamma matrices} 
matrices with the given trace\index{trace line} line 
index\index{index!trace line}. It assumes that the matrices are 
defined in four dimensions, hence it uses some relations that are only 
valid in four dimensions. For details about these relations and other 
methods used, consult chapter~\ref{gammaalgebra} on gamma matrices. The 
options are: \vspace{4mm}

\lefttabitem{contract\index{trace4!contract}}
\tabitem{Try to use the Chisholm\index{Chisholm} identity to eliminate this 
trace and contract it with other gamma matrices. See also 
\ref{substachisholm}. This is the default.}

\lefttabitem{nocontract\index{trace4!nocontract}}
\tabitem{Do not use the Chisholm\index{Chisholm} identity to eliminate this 
trace and contract it with other gamma matrices. See also 
\ref{substachisholm}.}

\lefttabitem{nosymmetrize\index{trace4!nosymmetrize}}
\tabitem{When using the Chisholm\index{Chisholm} identity to eliminate this 
trace and contract it with other gamma matrices, do not do it in the 
symmetric fashion, but use the first contraction encountered. See also 
\ref{substachisholm}.}

\lefttabitem{notrick\index{trace4!notrick}}
\tabitem{The final stage of trace taking, when all indices are different 
and there are no contractions with identical vectors, as well as no 
$\gamma_5$ matrices present, is done with n-dimensional methods, rather 
than with 4-dimensional tricks.}

\lefttabitem{symmetrize}
\tabitem{When using the Chisholm identity to eliminate this trace and 
contract it with other gamma matrices, try to do it in the symmetric 
fashion. See also \ref{substachisholm}.}

\lefttabitem{trick}
\tabitem{The final stage of trace taking, when all indices are different 
and there are no contractions with identical vectors is done using the 
4-dimensional relation

$\gamma^a\gamma^b\gamma^c = \epsilon^{abcd}\gamma_5\gamma^d
    +\gamma^a\delta^{bc}-\gamma^b\delta^{ac}+\gamma^c\delta^{ab}$

This gives a shorter result for long traces. It is the default.
} \vspace{10mm}

%--#] trace4 : 
%--#[ tracen :

\section{tracen}
\label{substatracen}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & tracen {\tt<}index{\tt>}; \\
See also & trace4 (\ref{substatrace}), chisholm (\ref{substachisholm}),
    unittrace (\ref{substaunittrace}) \\ &
    and the chapter on gamma algebra (\ref{gammaalgebra})
\end{tabular} \vspace{4mm}

\noindent Takes\index{tracen} the trace of the gamma\index{gamma matrices} 
matrices with the spin\index{spin line} line indicated by the index. It is 
assumed that the trace is over a symbolic number of dimensions. Hence no 
special 4-dimensional tricks are used. The presence of $\gamma_5$, 
$\gamma_6$ or $\gamma_7$ is not tolerated. When indices are contracted 
{\FORM} will try to use the special symbol for the dimension$-4$ if it has 
been defined in the declaration of the index (see \ref{substaindex}. This 
results in relatively compact expressions. For more details on the 
algorithm used, see chapter~\ref{gammaalgebra} on gamma matrices. 
\vspace{10mm}

%--#] tracen : 
%--#[ transform :
 
\section{transform}
\label{substatransform}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & transform,function(s),{\tt<}one or more transformations{\tt>};
\end{tabular} \vspace{4mm}

\noindent Statement\index{Transform} to manipulation function arguments and 
fields of arguments. Allows speedy transformations without the need of 
multiple statements or repeat loops.

The function(s) is/are indicated as individual, comma or blank space 
separated, functions or sets of functions.

If there is more than one transformation, the transformations are separated 
by comma's (or blanks, unless the blank space would not induce a comma).

Each transformation consists of its keyword, indicating its type, followed 
by a range of arguments that is enclosed by parentheses. After that 
specific information may follow. The range\index{last}\index{range} is as 
in
\begin{verbatim}
	(1,4)
	(3,last)
	(last-6,last-2)
\end{verbatim}
hence two indicators, separated by a comma. If the first number is bigger 
than the second the arguments will be processed in reverse order whenever 
this is relevant. In the descriptions below we will indicate the range by 
(r1,r2). The numbers in the above examples may be also dollar variables, 
provided they evaluate into numbers at the time of execution. Hence
\begin{verbatim}
	($x,$y)
	($x,last)
	(last-$x,last-2)
\end{verbatim}
are potentially legal ranges. One may not use \verb:$x+2: or other 
expressions that still need evaluation.

The transformations that are allowed currently are:
 
\leftvitem{3.2cm}{replace\index{transform!replace}\index{replace}}
\rightvitem{13cm}{replace(r1,r2)=(from1,to1,from2,to2,...,fromn,ton) in 
which the from-to pairs are as in the replace\_ function. Here however 
there are more options than in the replace\_ function as we can specify 
(small) numbers as well as in \\
replace(1,last)=(0,1,1,0) which would replace arguments that are zero by 
one and arguments that are one by zero. Generic arguments are indicated by 
the new variables xarg\_, iarg\_, parg\_ and farg\_ as in \\
replace(1,last)=(xarg\_,2\*xarg\_+1,p) which would replace f(2,a) by f(5,
2\*a+1,p) if a is a symbol and p a vector. To catch p one would need to use 
parg\_.}

\leftvitem{3.2cm}{encode\index{transform!encode}\index{encode}}
\rightvitem{13cm}{encode(r1,r2):base=number will interpret the arguments as 
the digits in a base 2 number system, compute the complete number and 
replace the arguments by a single argument that is that number. The number 
must fit inside a single \FORM{} word and so must each of the original 
arguments. They should actually be smaller than the number of the base.}

\leftvitem{3.2cm}{decode\index{transform!decode}\index{decode}}
\rightvitem{13cm}{decode(r1,r2):base=number will do the opposite of encode. 
It will take a single argument (the smallest of the two given) and expand 
it into digits in a number system given by the base. It will create the 
specified number of digits and replace the original number by the given 
number of arguments representing these digits. If r2 is less than r1 the 
digits will be in reverse order.}

\leftvitem{3.2cm}{tosumnotation\index{transform!tosumnotation}\index{tosumnotation}
\index{transform!implode}\index{implode}}
\rightvitem{13cm}{tosumnotation(r1,r2) or implode(r1,r2) realizes an 
encoding in which zeroes are absorbed as extra values in the first nonzero 
argument that is following. This is used when dealing with harmonic sums 
and harmonic polylogarithms. An example is that (0,0,1,0,a,0,0,0,-1) (which 
is in integral notation) goes into (3,2*a,-4) (which is in sum notation). 
Currently only a single symbol is allowed and the numbers should be (small) 
integers because otherwise the reverse operation (explode) would generate 
too many arguments. Instead of ``tosumnotation'' one may also use the word 
``implode'' in accordance with the argimplode statement.}

\leftvitem{3.2cm}{tointegralnotation\index{transform!tointegralnotation}
\index{tointegralnotation}\index{transform!explode}\index{explode}}
\rightvitem{13cm}{tointegralnotation(r1,r2) or explode(r1,r2) undoes what 
implode might have done. Hence each integer with an absolute value $n$ 
generates $n-1$ zeroes and leaves something with absolute value one. 
Instead of ``tointegralnotation'' one may also use the word 
``explode'' in accordance with the argexplode statement.}

\leftvitem{3.2cm}{permute\index{transform!permute}\index{permute}}
\rightvitem{13cm}{permute(1,3,5)(2,6) will permute the arguments 
according to the cycles indicated. The cycles are executed in order and may 
overlap. Their number is not restricted. In the above example
f(a1,a2,a3,a4,a5,a6,a7) $\rightarrow$ f(a3,a6,a5,a4,a1,a2,a7).
It is allowed to use \$-variables in the cycles, including \$-variables 
that are obtained by matching argument field wildcards.}

\leftvitem{3.2cm}{reverse\index{transform!reverse}\index{reverse}}
\rightvitem{13cm}{reverse(r1,r2) reverses the order of the arguments in 
specified range.}

\leftvitem{3.2cm}{dedup\index{transform!dedup}\index{dedup}}
\rightvitem{13cm}{dedup(r1,r2) removes duplicates from the arguments in the range, keeping the first.}

\leftvitem{3.2cm}{cycle\index{transform!cycle}\index{cycle}}
\rightvitem{13cm}{cycle(r1,r2)=+/-number will perform a cyclic permutation 
of the indicated range of arguments. If the number is preceded by a - the 
cycling is to the left. If there is a plus sign the cycling is to the 
right. Note that either the plus or the minus sign is mandatory. The number 
following the +/- sign is also allowed to be a dollar variable provided it 
evaluates to a legal number during execution.}

\leftvitem{3.2cm}{islyndon\index{transform!islyndon}\index{islyndon}}
\rightvitem{13cm}{islyndon(r1,r2)=(yes,no) will test whether the indicated 
range of arguments forms a Lyndon word\index{Lyndon word} according to the 
ordering of arguments in \FORM\@. The yes and no arguments are what the main 
term will be multiplied by when the range forms a Lyndon word or does not 
respectively. Because the definition of a Lyndon word is the unique minimal 
cyclic permutation of the arguments, and because often we may need the 
unique maximal cyclic permutation there are varieties: for the minimum one 
may also use islyndon$<$(r1,r2)=(yes,no) or islyndon-(r1,r2)=(yes,no), 
while for the maximum one may use islyndon$>$(r1,r2)=(yes,no) or 
islyndon+(r1,r2)=(yes,no).}

\leftvitem{3.2cm}{tolyndon\index{transform!tolyndon}\index{tolyndon}}
\rightvitem{13cm}{tolyndon(r1,r2)=(yes,no) will permute the given range in 
a cyclic manner till it is (if possible) a Lyndon word\index{Lyndon word} 
according to the ordering of arguments in \FORM\@. The yes and no arguments 
are what the main term will be multiplied by when afterwards the range 
forms a Lyndon word or does not respectively. Because the definition of a 
Lyndon word is the unique minimal cyclic permutation of the arguments, and 
because often we may need the unique maximal cyclic permutation there are 
varieties: for the minimum one may also use tolyndon$<$(r1,r2)=(yes,no) or 
tolyndon-(r1,r2)=(yes,no), while for the maximum one may use 
tolyndon$>$(r1,r2)=(yes,no) or tolyndon+(r1,r2)=(yes,no). If the output is 
not a Lyndon word, this will be due to that it is a minimum or maximum that 
is not unique.}

\leftvitem{3.2cm}{addargs\index{transform!addargs}\index{addargs}}
\rightvitem{13cm}{addargs(r1,r2) replaces the indicated range of arguments 
by their sum. This is effectively the inverse of the SplitArg statement.}

\leftvitem{3.2cm}{mulargs\index{transform!mulargs}\index{mulargs}}
\rightvitem{13cm}{mulargs(r1,r2) replaces the indicated range of arguments 
by their product. This is effectively the inverse of the FactArg statement.}

\leftvitem{3.2cm}{dropargs\index{transform!dropargs}\index{dropargs}}
\rightvitem{13cm}{dropargs(r1,r2) removes the indicated range of arguments.}

\leftvitem{3.2cm}{selectargs\index{transform!selectargs}\index{selectargs}}
\rightvitem{13cm}{selectargs(r1,r2) removes all arguments with the exception 
of the indicated range of arguments.}

Some Examples. Assume that we have some Multiple Zeta Values\index{Multiple 
Zeta Value}\index{MZV} (see the papers on harmonic sums\index{harmonic 
sums}, harmonic polylogarithms\index{harmonic polylogarithm} and the MZV 
data mine\index{MZV data mine}) in the sum notation, but for calculational 
reason we want to use a binary encoding (as used in the MZV programs). We 
could have
% THIS EXAMPLE IS PART OF THE TESTSUITE. CHANGES HERE SHOULD BE APPLIED THERE AS
% WELL! (Sta_Transform_1)
\begin{verbatim}
    Symbol x,x1,x2;
    CF  H,H1;
    Off Statistics;
    L   F = H(3,4,2,6,1,1,1,2);
    repeat id H(?a,x?!{0,1},?b) = H(?a,0,x-1,?b);
    Print;
    .sort

   F =
      H(0,0,1,0,0,0,1,0,1,0,0,0,0,0,1,1,1,1,0,1);

    Multiply H1;
    repeat id H(x?,?a)*H1(?b) = H(?a)*H1(?b,1-x);
    id  H1(?a)*H = H(?a);
    Print;
    .sort

   F =
      H(1,1,0,1,1,1,0,1,0,1,1,1,1,1,0,0,0,0,1,0);

    repeat id H(x1?,x2?,?a) = H(2*x1+x2,?a);
    Print;
    .end

   F =
      H(907202);
\end{verbatim}
The new version of the same program would be
\begin{verbatim}
    Symbol x,x1,x2;
    CF  H,H1;
    Off Statistics;
    L   F = H(3,4,2,6,1,1,1,2);
    Transform,H,explode(1,last),
                replace(1,last)=(0,1,1,0),
                encode(1,last):base=2;
    Print;
    .end

   F =
      H(907202);
\end{verbatim}
It should be clear that this is simpler and faster. On a 64-bits computer 
it is faster by more than a factor 100.

\vspace{10mm}

%--#] transform : 
%--#[ tryreplace :

\section{tryreplace}
\label{substatryreplace}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & tryreplace \verb:{:{\tt<}name{\tt>} {\tt<}replacement{\tt>}\verb:}:;
\\ See also & the replace\_ function (\ref{funreplace})
\end{tabular} \vspace{4mm}

\noindent The list\index{tryreplace} of potential replacements should be 
similar to the arguments of the replace\_\index{replace\_} 
function\index{function!replace\_} (see \ref{funreplace}). {\FORM} will 
make a copy of the current term, try the replacement and if the replacement 
results in a term which, by the internal ordering of {\FORM}, comes before 
the current term, the current term is replaced by the new variety. 
\vspace{10mm}

%--#] tryreplace : 
%--#[ unfactorize :

\section{unfactorize}
\label{substaunfactorize}

\noindent \begin{tabular}{ll}
Type & Output control statement\\
Syntax & unfactorize \verb:{:{\tt<}name of expression(s){\tt>}\verb:}:;
\\ See also & the chapter on polynomials~\ref{polynomials} and the 
factorize statement~\ref{substafactorize}.
\end{tabular} \vspace{4mm}

\noindent Without arguments the statement causes all expressions that were 
factorized to be 'unfactorized'. This means that all factors are multiplied 
and the expression is replaced by this new version. Like the factorize 
statement this statement is an output control statement, which means that 
it takes effect after an expression has been processed in the current 
module (see also the factorize~\ref{substafactorize} statement).

\noindent Because an immediate multiplication of all factors is sometimes 
far from optimal, \FORM{} uses a binary scheme to combine factors. After each 
step there will be a sort operation. This means that when statistics are 
printed, there may be several statistics for this step.

\noindent When the statement has arguments, these arguments should be names 
of expressions. In that case the unfactorization is applied only to the 
expressions that are specified.

\noindent If one likes to unfactorized all expressions except for a few 
ones, one can use the unfactorize statement without arguments and then 
exclude the few expressions that should not be treated with the 
nunfactorize statement (see \ref{substanunfactorize}).
\vspace{10mm} 

%--#] unfactorize : 
%--#[ unhide :

\section{unhide}
\label{substaunhide}

\noindent \begin{tabular}{ll}
Type & Specification statement\\
Syntax & unhide; \\
       & unhide {\tt<}list of expressions{\tt>};
\\ See also & hide (\ref{substahide}),
              nhide (\ref{substanhide}),
              nunhide (\ref{substanunhide}),
              pushhide (\ref{substapushhide}),
              pophide (\ref{substapophide})
\end{tabular} \vspace{4mm}

\noindent In its\index{unhide} first variety this statement causes all 
statements in the hide\index{hide} file\index{file!hide} to become 
active\index{active} expressions again. In its second variety only the 
specified expressions are taken from the hide system and become active 
again. An expression that is made active again can be manipulated again in 
the module in which the unhide statement occurs. For more information one 
should look at the hide statement in \ref{substahide}. \vspace{4mm}

\noindent Note that if only a number of expressions is taken from the hide 
system, the hide file may be left with `holes', i.e.\ space between the 
remaining expressions that contain no relevant information any longer. 
{\FORM} contains no mechanism to use the space in these holes. Hence if 
space is at a premium and many holes develop one should unhide all 
expressions (this causes the hide system to be started from zero size 
again) and then send the relevant expressions back to the hide system. 
\vspace{10mm}

%--#] unhide : 
%--#[ unittrace :

\section{unittrace}
\label{substaunittrace}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & u[nittrace] {\tt<}value{\tt>}; \\
See also & trace4 (\ref{substatrace}), tracen (\ref{substatracen}),
    chisholm (\ref{substachisholm}) \\ &
    and the chapter on gamma algebra (\ref{gammaalgebra}).
\end{tabular} \vspace{4mm}

\noindent Sets\index{unittrace} the value of the trace of the 
unit\index{unit matrix} matrix\index{matrix!unit} in the Dirac\index{Dirac} 
algebra\index{algebra!Dirac} (i.e.\ the object \verb:g1_(n): for trace line 
\verb:n:)). The parameter \verb:value: can be either a short positive 
number or any symbol with the exception of \verb:i_:. See also 
chapter~\ref{gammaalgebra}. \vspace{10mm}

%--#] unittrace : 
%--#[ vectors :

\section{vectors}
\label{substavectors}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & v[ectors] {\tt<}list of vectors to be declared{\tt>};
\end{tabular} \vspace{4mm}

\noindent Used for the declaration of vectors\index{vector}. Example:
\begin{verbatim}
   Vectors p,q,q1,q2,q3;
\end{verbatim}
\vspace{10mm}

%--#] vectors : 
%--#[ while :

\section{while}
\label{substawhile}

\noindent \begin{tabular}{ll}
Type & Executable statement\\
Syntax & while ( condition );
\\ See also & endwhile (\ref{substaendwhile}), repeat (\ref{substarepeat}),
            if (\ref{substaif})
\end{tabular} \vspace{4mm}

\noindent This statement\index{while} starts the while 
environment\index{environment!while}. It should be paired with an 
endwhile\index{endwhile} statement (see \ref{substaendwhile}) which 
terminates the while environment. The statements between the while and the 
endwhile statements will be executed as long as the condition is met. For 
the description of the condition one should consult the if\index{if} 
statement (see \ref{substaif}). The while/endwhile combination is 
equivalent to the construction
\begin{verbatim}
   repeat;
      if ( condition );


      endif;
   endrepeat;
\end{verbatim}
If only a single statement is inside the environment one can also use
\begin{verbatim}
   while ( condition ) statement;
\end{verbatim}
Of course one should try to avoid infinite\index{infinite loop} 
loops\index{loops!infinite}. In order to maximize the speed of {\FORM} not 
all internal stacks are protected and hence the result may be that {\FORM} 
may crash. It is also possible that {\FORM} may detect a shortage of buffer 
space and quit with an error message. \vspace{4mm}

\noindent For each term for which execution reaches the endwhile statement, 
control is brought back to the while statement. For each term that reaches 
the while statement the condition is checked and if it is met, the 
statements inside the environment are executed again on this term. If the 
condition is not met, execution continues after the endwhile statement. 
\vspace{10mm}

%--#] while : 
%--#[ write :

\section{write}
\label{substawrite}

\noindent \begin{tabular}{ll}
Type & Declaration statement\\
Syntax & w[rite] {\tt<}keyword{\tt>};
\\ See also & on (\ref{substaon}), off (\ref{substaoff})
\end{tabular} \vspace{4mm}

\noindent This statement\index{write} is considered 
obsolete\index{obsolete}. All its varieties have been taken over by the 
on\index{on} statement (see \ref{substaon}) and the off\index{off} 
statement (see \ref{substaoff}). The current version of {\FORM} will still 
recognize it, but the user is advised to avoid its usage. In future 
versions of {\FORM} it is scheduled to be used for a different kind of 
writing and hence its syntax may change considerably. The conversion 
program conv2to3 should help in the conversion of programs written for 
version 2. For completeness we still give the syntax and how it should be 
converted. The keywords are: \vspace{4mm}
 
\leftvitem{3.5cm}{allnames\index{write!allnames}}
\rightvitem{13cm}{Same as: On allnames;}

\leftvitem{3.5cm}{allwarnings\index{write!allwarnings}}
\rightvitem{13cm}{Same as: On allwarnings;}
 
\leftvitem{3.5cm}{highfirst\index{write!highfirst}}
\rightvitem{13cm}{Same as: On highfirst;}
 
\leftvitem{3.5cm}{lowfirst\index{write!lowfirst}}
\rightvitem{13cm}{Same as: On lowfirst;}

\leftvitem{3.5cm}{names\index{write!names}}
\rightvitem{13cm}{Same as: On names;}
 
\leftvitem{3.5cm}{powerfirst\index{write!powerfirst}}
\rightvitem{13cm}{Same as: On powerfirst;}
 
\leftvitem{3.5cm}{setup\index{write!setup}}
\rightvitem{13cm}{Same as: On setup;}
 
\leftvitem{3.5cm}{shortstatistics\index{write!shortstatistics}}
\rightvitem{13cm}{Same as: On shortstatistics;}

\leftvitem{3.5cm}{shortstats\index{write!shortstats}}
\rightvitem{13cm}{Same as: On shortstats;}
 
\leftvitem{3.5cm}{statistics\index{write!statistics}}
\rightvitem{13cm}{Same as: On statistics;}
 
\leftvitem{3.5cm}{stats\index{write!stats}}
\rightvitem{13cm}{Same as: On stats;}
 
\leftvitem{3.5cm}{warnings\index{write!warnings}}
\rightvitem{13cm}{Same as: On warnings;}

\vspace{10mm}

%--#] write : 

